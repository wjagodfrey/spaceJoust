// Generated by CoffeeScript 1.9.0
(function() {
  var Item, Item_Spawner, Player, addPlayerVelocity, applyPhysics, bombId, clearFrameTimeouts, colors, entity, events, fireEvent, frameCount, frameTimeouts, gameCanvas, gameCq, gameKeys, gameMusic, gravity, hasBoxHit, hasMouseHit, item, level, levels, lightenDarkenColor, loadLevel, loaded, loadedFrameCount, mouse, mouseDownHandler, mouseMoveHandler, mouseUpHandler, onEvent, playOneOf, players, removePlayerVelocity, resizeFactor, root, setFrameTimeout, sound, soundsLoadedCount, soundsToLoad, touchDown, touchMove, touchTimeout, updateFrameTimeouts,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  root = this;

  loaded = false;

  touchDown = false;

  sound = {};

  gameMusic = {};

  this.levels = levels = {};

  this.players = players = {};

  this.item = item = {};

  this.entity = entity = {};

  this.level = level = void 0;

  resizeFactor = 2;

  gravity = 0.1;

  colors = {
    playerFlesh: '#D6BC9B',
    players: {
      red: '#E0352E',
      blue: '#3D89F8'
    },
    life: '#8aff58',
    invincible: '#64F0FF',
    noWingsEnemy: '#FECA47',
    bomb: {
      off: '#939393',
      on: '#FC2639',
      background: '#222222'
    },
    slime: {
      main: '#F9631E'
    },
    item: 'white',
    controlsDisplay: {
      keyColor: '#E8E8E8',
      specialKeyColor: '#DE5A29',
      textColor: '#202020',
      specialTextColor: '#FFFFFF'
    }
  };

  gameKeys = {
    'm': function() {
      return typeof gameMusic.setMute === "function" ? gameMusic.setMute(!gameMusic.getMute()) : void 0;
    }
  };

  'use strict';

  events = {};

  onEvent = function(eventName, eventHandler) {
    if (events[eventName] == null) {
      events[eventName] = [];
    }
    events[eventName].push(eventHandler);
    return function() {
      return events[eventName].splice(events[eventName].indexOf(eventHandler), 1);
    };
  };

  fireEvent = function() {
    var args, eventHandler, eventName, _i, _len, _ref, _ref1, _results;
    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((_ref = events[eventName]) != null ? _ref.length : void 0) {
      _ref1 = events[eventName];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        eventHandler = _ref1[_i];
        _results.push(eventHandler.apply(null, args));
      }
      return _results;
    }
  };

  playOneOf = function(sounds) {
    var randomSound;
    randomSound = Math.round(Math.random() * (sounds.length - 1));
    return sound.play(sounds[randomSound]);
  };

  this.frameCount = 0;

  this.frameTimeouts = frameTimeouts = {};

  setFrameTimeout = function(callback, time) {
    var removed, targetFrame;
    if (time == null) {
      time = 0;
    }
    targetFrame = root.frameCount + Math.ceil(time * 0.06);
    if (targetFrame <= (root.frameCount + 1)) {
      return setTimeout(callback);
    } else {
      if (frameTimeouts[targetFrame] == null) {
        frameTimeouts[targetFrame] = [];
      }
      frameTimeouts[targetFrame].push(callback);
      removed = false;
      return (function(_this) {
        return function() {
          if (!removed) {
            if (frameTimeouts[targetFrame]) {
              frameTimeouts[targetFrame].splice(frameTimeouts[targetFrame].indexOf(callback), 1);
            }
            return removed = true;
          }
        };
      })(this);
    }
  };

  updateFrameTimeouts = function() {
    var callback, targetFrame, _i, _len, _ref;
    targetFrame = root.frameCount++;
    if (frameTimeouts[targetFrame]) {
      _ref = frameTimeouts[targetFrame];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback();
      }
      frameTimeouts[targetFrame] = void 0;
      return delete frameTimeouts[targetFrame];
    }
  };

  clearFrameTimeouts = function() {
    var callback, targetFrame, _results;
    _results = [];
    for (targetFrame in frameTimeouts) {
      callback = frameTimeouts[targetFrame];
      _results.push(delete frameTimeouts[targetFrame]);
    }
    return _results;
  };

  hasMouseHit = function(x, y, width, height) {
    var col;
    col = {
      x: x + width / 2 >= mouse.x && x - width / 2 <= mouse.x,
      y: y + height / 2 >= mouse.y && y - height / 2 <= mouse.y
    };
    if (col.x && col.y) {
      return true;
    } else {
      return false;
    }
  };

  hasBoxHit = function(_ax, _ay, _awidth, _aheight, _bx, _by, _bwidth, _bheight) {
    var aX, aXX, aY, aYY, bX, bXX, bY, bYY, col;
    aX = _ax;
    aXX = _ax + _awidth;
    aY = _ay;
    aYY = _ay + _aheight;
    bX = _bx;
    bXX = _bx + _bwidth;
    bY = _by;
    bYY = _by + _bheight;
    col = {
      x: (aX >= bX && aX <= bXX || aXX >= bX && aXX <= bXX) || (bX >= aX && bX <= aXX || bXX >= aX && bXX <= aXX),
      y: (aY >= bY && aY <= bYY || aYY >= bY && aYY <= bYY) || (bY >= aY && bY <= aYY || bYY >= aY && bYY <= aYY)
    };
    if (col.x && col.y) {
      return {
        left: aX >= bX && aX <= bXX,
        right: aXX >= bX && aXX <= bXX,
        top: aY >= bY && aY <= bYY,
        bottom: aYY >= bY && aYY <= bYY
      };
    } else {
      return false;
    }
  };

  this.lightenDarkenColor = lightenDarkenColor = function(col, amt) {
    var b, g, num, r, usePound;
    usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    num = parseInt(col, 16);
    r = (num >> 16) + amt;
    if (r > 255) {
      r = 255;
    } else {
      if (r < 0) {
        r = 0;
      }
    }
    b = ((num >> 8) & 0x00FF) + amt;
    if (b > 255) {
      b = 255;
    } else {
      if (b < 0) {
        b = 0;
      }
    }
    g = (num & 0x0000FF) + amt;
    if (g > 255) {
      g = 255;
    } else {
      if (g < 0) {
        g = 0;
      }
    }
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16);
  };

  loadLevel = (function(_this) {
    return function(name) {
      root.level = level = levels["level_" + name] || {};
      return typeof level.onBuild === "function" ? level.onBuild() : void 0;
    };
  })(this);

  addPlayerVelocity = function(player, name, vector) {
    players[player].vel.mod[name] = {};
    if (vector.x) {
      players[player].vel.mod[name].x = vector.x;
    }
    if (vector.y) {
      return players[player].vel.mod[name].y = vector.y;
    }
  };

  removePlayerVelocity = function(player, name) {
    return delete players[player].vel.mod[name];
  };

  applyPhysics = function(ent1) {
    var col, correction, ent1Collisions, ent1Solid, ent2, ent2Collisions, ent2Solid, entSource, i, runCorrection, xCorrection, xDepth, yCorrection, yDepth, _i, _len, _ref;
    xCorrection = 1;
    yCorrection = 1;
    _ref = [level != null ? level.midground : void 0, players];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entSource = _ref[_i];
      for (i in entSource) {
        ent2 = entSource[i];
        if (ent1 !== ent2) {
          if (col = hasBoxHit(ent1.x + ent1.vel.x, ent1.y + ent1.vel.y, ent1.width, ent1.height, ent2.x, ent2.y, ent2.width, ent2.height)) {
            ent1Solid = typeof ent1.isSolidTo === "function" ? ent1.isSolidTo(ent2) : void 0;
            ent2Solid = typeof ent2.isSolidTo === "function" ? ent2.isSolidTo(ent1) : void 0;
            ent1Collisions = {
              top: false,
              bottom: false,
              left: false,
              right: false
            };
            ent2Collisions = {
              top: false,
              bottom: false,
              left: false,
              right: false
            };
            if (ent1Solid && ent2Solid) {
              xDepth = 0;
              yDepth = 0;
              if (col.left && col.right) {
                xDepth = ent1.width;
              } else if (!col.left && !col.right) {
                xDepth = ent2.width;
              } else if (col.left && !col.right) {
                xDepth = ent1.width - ((ent1.x + ent1.vel.x + ent1.width) - (ent2.x + ent2.width));
              } else if (!col.left && col.right) {
                xDepth = ent1.width - (ent2.x - (ent1.x + ent1.vel.x));
              }
              if (col.top && col.bottom) {
                yDepth = ent1.height;
              } else if (!col.top && !col.bottom) {
                yDepth = ent2.height;
              } else if (col.top && !col.bottom) {
                yDepth = ent1.height - ((ent1.y + ent1.vel.y + ent1.height) - (ent2.y + ent2.height));
              } else if (!col.top && col.bottom) {
                yDepth = ent1.height - (ent2.y - (ent1.y + ent1.vel.y));
              }
              runCorrection = !(typeof ent1.noCorrectionWith === "function" ? ent1.noCorrectionWith(ent2) : void 0) && !(typeof ent2.noCorrectionWith === "function" ? ent2.noCorrectionWith(ent1) : void 0);
              if (xDepth && yDepth) {
                if ((xDepth < yDepth || !ent1.vel.y) && ent1.vel.x < 0 && (col.left || !col.right)) {
                  if (runCorrection) {
                    correction = (ent1.x - (ent2.x + ent2.width)) / Math.abs(ent1.vel.x);
                    if (correction < xCorrection) {
                      xCorrection = correction;
                    }
                  }
                  ent1Collisions.left = true;
                  ent2Collisions.right = true;
                } else if ((xDepth < yDepth || !ent1.vel.y) && ent1.vel.x > 0 && (col.right || !col.left)) {
                  if (runCorrection) {
                    correction = (ent2.x - (ent1.x + ent1.width)) / Math.abs(ent1.vel.x);
                    if (correction < xCorrection) {
                      xCorrection = correction;
                    }
                  }
                  ent1Collisions.right = true;
                  ent2Collisions.left = true;
                }
                if ((yDepth < xDepth || !ent1.vel.x) && ent1.vel.y < 0 && (col.top || !col.bottom)) {
                  if (runCorrection) {
                    correction = (ent1.y - (ent2.y + ent2.height)) / Math.abs(ent1.vel.y);
                    if (correction < yCorrection) {
                      yCorrection = correction;
                    }
                  }
                  ent1Collisions.top = true;
                  ent2Collisions.bottom = true;
                } else if ((yDepth < xDepth || !ent1.vel.x) && ent1.vel.y > 0 && (col.bottom || !col.top)) {
                  if (runCorrection) {
                    correction = (ent2.y - (ent1.y + ent1.height)) / Math.abs(ent1.vel.y);
                    if (correction < yCorrection) {
                      yCorrection = correction;
                    }
                  }
                  ent1Collisions.bottom = true;
                  ent2Collisions.top = true;
                }
              }
            }
            if (typeof ent2.onHit === "function") {
              ent2.onHit(ent2Collisions, ent1, ent1Solid);
            }
            if (typeof ent1.onHit === "function") {
              ent1.onHit(ent1Collisions, ent2, ent2Solid);
            }
          }
        }
      }
    }
    ent1.x += ent1.vel.x * xCorrection;
    return ent1.y += ent1.vel.y * yCorrection;
  };

  loaded = false;

  frameCount = 0;

  loadedFrameCount = 0;

  soundsLoadedCount = 0;

  soundsToLoad = [
    {
      src: "sounds/BoxCat_Games_-_03_-_Battle_Special.mp3",
      id: "gameMusic"
    }, {
      src: "sounds/Buzzer-SoundBible.com-188422102.mp3",
      id: "buzzer"
    }, {
      src: "sounds/Blop-Mark_DiAngelo-79054334.mp3",
      id: "blop"
    }, {
      src: "sounds/Baseball Bat Swing-SoundBible.com-1511319491.mp3",
      id: "flap"
    }, {
      src: "sounds/Click2-Sebastian-759472264.mp3",
      id: "button_up"
    }, {
      src: "sounds/Button-SoundBible.com-1420500901.mp3",
      id: "button_down"
    }, {
      src: "sounds/Barrel Exploding-SoundBible.com-1134967902.mp3",
      id: "explosion1"
    }, {
      src: "sounds/Explosion 2-SoundBible.com-1641389556.mp3",
      id: "explosion2"
    }, {
      src: "sounds/Grenade Explosion-SoundBible.com-2100581469.mp3",
      id: "explosion3"
    }, {
      src: "sounds/Small Fireball-SoundBible.com-1381880822.mp3",
      id: "burn_small"
    }, {
      src: "sounds/Large Fireball-SoundBible.com-301502490.mp3",
      id: "burn_large"
    }, {
      src: "sounds/Fizzle-SoundBible.com-1439537520.mp3",
      id: "electricburn"
    }, {
      src: "sounds/Drop Fork-SoundBible.com-309369294.mp3",
      id: "placeBomb"
    }, {
      src: "sounds/Slap-SoundMaster13-49669815.mp3",
      id: "pop"
    }
  ];

  root.onload = function() {
    sound = createjs.Sound;
    sound.alternateExtensions = ["mp3"];
    sound.on("fileload", function() {
      if (soundsLoadedCount++ === soundsToLoad.length - 1) {
        return setTimeout(function() {
          loaded = true;
          return fireEvent('assetsLoaded');
        }, 2000);
      }
    });
    return sound.registerSounds(soundsToLoad);
  };

  entity.Boundary = (function() {
    function Boundary(_at_x, _at_y, _at_width, _at_height) {
      this.x = _at_x;
      this.y = _at_y;
      this.width = _at_width;
      this.height = _at_height;
      this.type = 'Boundary';
      this.cache = {};
    }

    Boundary.prototype.isSolidTo = function() {
      return true;
    };

    Boundary.prototype.draw = function(ctx) {
      return ctx.fillStyle('#1b1b1b').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Boundary;

  })();

  entity.Button = (function() {
    function Button(_at_x, _at_y, _at_onPress, _at_onRelease, _at_once, _at_color) {
      this.x = _at_x;
      this.y = _at_y;
      this.onPress = _at_onPress;
      this.onRelease = _at_onRelease;
      this.once = _at_once;
      this.color = _at_color != null ? _at_color : '#972d32';
      this.width = 4;
      this.height = 2;
      this.type = 'Button';
      this.pressed = false;
      this.cache = {};
    }

    Button.prototype.isSolidTo = function() {
      return true;
    };

    Button.prototype.onHit = function(col, ent) {
      var _ref;
      if ((_ref = ent.type) === 'Player' || _ref === 'Bomb') {
        this.hadHit = true;
        if ((col.top || col.right || col.left) && !this.pressed) {
          if (!this.pressed) {
            sound.play('button_up');
          }
          this.pressed = true;
          this.yCache = this.y;
          this.height = 1;
          this.y = this.yCache + 1;
          ent.y = this.y - ent.height;
          return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
        } else if ((this.yCache != null) && !this.once) {
          sound.play('button_down');
          return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
        }
      }
    };

    Button.prototype.update = function() {
      if (!this.hadHit && this.pressed) {
        this.pressed = false;
        this.height = 2;
        this.y = this.yCache;
        delete this.yCache;
        sound.play('button_up');
        if (typeof this.onRelease === "function") {
          this.onRelease();
        }
      }
      return this.hadHit = false;
    };

    Button.prototype.draw = function(ctx) {
      return ctx.fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Button;

  })();

  entity.Laser = (function() {
    function Laser(_at_x, _at_y, _at_width, _at_height, _at_on, _at_color) {
      this.x = _at_x;
      this.y = _at_y;
      this.width = _at_width;
      this.height = _at_height;
      this.on = _at_on != null ? _at_on : false;
      this.color = _at_color != null ? _at_color : '#972d32';
      this.type = 'Laser';
      this.cache = {};
    }

    Laser.prototype.isSolidTo = function(ent) {
      return this.on;
    };

    Laser.prototype.onHit = function(col, ent) {
      if (this.on && ent.type === 'Player') {
        sound.play('electricburn');
        return ent.die();
      }
    };

    Laser.prototype.draw = function(ctx) {
      var alpha;
      alpha = this.on ? 1 : 0.1;
      return ctx.save().globalAlpha(alpha).fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Laser;

  })();

  entity.PlayerSpawn = (function() {
    function PlayerSpawn(_at_x, _at_y, playerType) {
      var _ref;
      this.x = _at_x;
      this.y = _at_y;
      this.player = players[playerType.toLowerCase()];
      this.width = 20;
      this.height = 3;
      if ((_ref = this.player) != null) {
        _ref.spawn = this;
      }
      this.type = 'Spawn';
      this.lifeCounterOn = lightenDarkenColor(colors.life, 0);
      this.lifeCounterOff = lightenDarkenColor(colors.life, -100);
      this.beamHeight = 25;
      this.beamAlpha = 0;
      this.cache = {};
      this.controlsDisplay = {
        alpha: 1,
        fade: false,
        width: 8,
        height: 8,
        margin: 2,
        keyDepth: 1,
        faderTimeout: setTimeout((function(_this) {
          return function() {
            return _this.controlsDisplay.fade = true;
          };
        })(this), 3000)
      };
    }

    PlayerSpawn.prototype.lockoutCount = 30;

    PlayerSpawn.prototype.isSolidTo = function(ent) {
      return true;
    };

    PlayerSpawn.prototype.onBuild = function(level) {
      return this.reset();
    };

    PlayerSpawn.prototype.reset = function() {
      var _ref, _ref1, _ref2, _ref3;
      if ((_ref = this.player) != null) {
        _ref.x = this.x + this.width / 2 - ((_ref1 = this.player) != null ? _ref1.width : void 0) / 2;
      }
      if ((_ref2 = this.player) != null) {
        _ref2.y = this.y + this.height / 2 - ((_ref3 = this.player) != null ? _ref3.height : void 0) / 2 - 15;
      }
      this.beamAlpha = 0.8;
      this.player.invincible = true;
      this.player.invincibleTimeout = setFrameTimeout((function(_this) {
        return function() {
          return _this.player.invincible = false;
        };
      })(this), 1000);
      return sound.play('buzzer');
    };

    PlayerSpawn.prototype.update = function() {
      if (this.beamAlpha > 0) {
        this.beamAlpha -= 0.05;
        if (this.beamAlpha < 0) {
          this.beamAlpha = 0;
        }
      }
      if (this.controlsDisplay.fade && this.controlsDisplay.alpha > 0) {
        this.controlsDisplay.alpha -= 0.05;
        if (this.controlsDisplay.alpha < 0) {
          return this.controlsDisplay.alpha = 0;
        }
      }
    };

    PlayerSpawn.prototype.draw = function(ctx) {
      var barWidth, isRed, keyColor, keyOpt, keyOpts, lifeCount, textColor, totalXOffset, totalYOffset, _i, _len, _results;
      ctx.save().globalAlpha(0.6).fillStyle(lightenDarkenColor(this.player.color, 50)).fillRect(Math.round(this.x), Math.round(this.y - 1), this.width, this.height).restore();
      ctx.save().globalAlpha(this.beamAlpha).fillStyle(this.player.color).fillRect(Math.round(this.x), Math.round(this.y - this.beamHeight), this.width, this.beamHeight).restore();
      ctx.save().fillStyle('#303030').fillRect(Math.round(this.x), Math.round(this.y + this.height - 3), this.width, 4).restore();
      barWidth = Math.floor(this.width / this.player.maxLives);
      lifeCount = 0;
      while (lifeCount < this.player.maxLives) {
        ctx.save().fillStyle(lifeCount >= this.player.lives ? this.lifeCounterOff : this.lifeCounterOn).fillRect(Math.round(this.x + (barWidth * lifeCount)), Math.round((this.y + this.height) - 2), barWidth, 2).restore();
        lifeCount++;
      }
      totalXOffset = this.controlsDisplay.width + this.controlsDisplay.margin;
      totalYOffset = this.controlsDisplay.height + this.controlsDisplay.margin + this.controlsDisplay.keyDepth;
      isRed = this.player.playerType === 'red';
      keyOpts = [
        {
          x: Math.round(this.x + this.width / 2 - this.controlsDisplay.width / 2),
          y: Math.round(this.y - 20 - totalYOffset * 2),
          text: isRed ? 'W' : '⬆'
        }, {
          x: Math.round(this.x + this.width / 2 - this.controlsDisplay.width / 2),
          y: Math.round(this.y - 20 - totalYOffset),
          text: isRed ? 'S' : '⬇'
        }, {
          x: Math.round(this.x + this.width / 2 - this.controlsDisplay.width / 2 - totalXOffset),
          y: Math.round(this.y - 20 - totalYOffset),
          text: isRed ? 'A' : '⬅'
        }, {
          x: Math.round(this.x + this.width / 2 - this.controlsDisplay.width / 2 + totalXOffset),
          y: Math.round(this.y - 20 - totalYOffset),
          text: isRed ? 'D' : '➡'
        }, {
          x: Math.round(this.x + this.width / 2 - this.controlsDisplay.width / 2 + (totalXOffset * 2) * (isRed ? 1 : -1)),
          y: Math.round(this.y - 20 - totalYOffset),
          text: isRed ? 'G' : '.',
          keyColor: colors.controlsDisplay.specialKeyColor,
          textColor: colors.controlsDisplay.specialTextColor
        }
      ];
      _results = [];
      for (_i = 0, _len = keyOpts.length; _i < _len; _i++) {
        keyOpt = keyOpts[_i];
        keyColor = keyOpt.keyColor || colors.controlsDisplay.keyColor;
        textColor = keyOpt.textColor || colors.controlsDisplay.textColor;
        _results.push(ctx.save().globalAlpha(this.controlsDisplay.alpha).fillStyle(keyColor).fillRect(keyOpt.x, keyOpt.y, this.controlsDisplay.width, this.controlsDisplay.height).fillStyle(lightenDarkenColor(keyColor, -50)).fillRect(keyOpt.x, keyOpt.y + this.controlsDisplay.height, this.controlsDisplay.width, this.controlsDisplay.keyDepth).fillStyle(textColor).font('8px Helvetica').textAlign('center').textBaseline('middle').wrappedText(keyOpt.text, keyOpt.x + this.controlsDisplay.width / 2, keyOpt.y + this.controlsDisplay.height / 2 + 1).restore());
      }
      return _results;
    };

    return PlayerSpawn;

  })();

  entity.Bomb = (function() {
    function Bomb(_at_ent, _at_key, _at_xBounce, _at_yBounce) {
      this.ent = _at_ent;
      this.key = _at_key;
      this.xBounce = _at_xBounce;
      this.yBounce = _at_yBounce;
      this.type = 'Bomb';
      this.x = this.ent.x + this.ent.width / 2 - 3;
      this.y = this.ent.y + this.ent.height / 2 - 3;
      this.width = 6;
      this.height = 6;
      this.force = 1.3;
      this.direction = {
        x: Math.round(Math.random()) || -1,
        y: Math.round(Math.random()) || -1
      };
      this.vel = {
        x: 0,
        y: 0
      };
      this.explode = {
        exploding: false,
        size: 0,
        sizeSpeed: 8,
        sizeLimit: 40,
        color: '#ffe2d0'
      };
      this.armed = false;
      this.hitCount = 0;
      this.updateCount = 0;
      this.lockoutCount = this.yBounce || this.xBounce ? 20 : 5;
      this.cache = {};
    }

    Bomb.prototype.noCorrectionWith = function(ent) {
      var _ref;
      return (_ref = ent.type) === 'Lava' || _ref === 'Laser';
    };

    Bomb.prototype.isSolidTo = function(ent) {
      return this.armed;
    };

    Bomb.prototype.boom = function() {
      level.shake.start();
      if (!this.explode.exploding) {
        playOneOf(['explosion1', 'explosion2', 'explosion3']);
      }
      return this.explode.exploding = true;
    };

    Bomb.prototype.update = function() {
      var ent, _ref, _ref1;
      if (!this.armed) {
        this.updateCount++;
        if (this.updateCount - this.hitCount > this.lockoutCount) {
          return this.armed = true;
        }
      } else {
        if (this.explode.exploding) {
          if (this.explode.size < this.explode.sizeLimit) {
            this.explode.size += this.explode.sizeSpeed;
            ent = this.ent;
            applyPhysics({
              isSolidTo: function() {
                return true;
              },
              type: 'Explosion',
              x: this.x - this.explode.size / 2,
              y: this.y - this.explode.size / 2,
              width: this.explode.size,
              height: this.explode.size,
              vel: {
                x: 0,
                y: 0
              },
              onHit: function(c, e, solid) {
                if (e.type === 'Player') {
                  return e.die();
                }
              }
            });
          } else {
            if ((_ref = level.midground) != null) {
              _ref[this.key] = void 0;
            }
            if ((_ref1 = level.midground) != null) {
              delete _ref1[this.key];
            }
          }
        } else if (this.xBounce || this.yBounce) {
          if (this.yBounce) {
            this.vel.y = this.force * this.direction.y;
          }
          if (this.xBounce) {
            this.vel.x = this.force * this.direction.x;
          }
        }
        return applyPhysics(this);
      }
    };

    Bomb.prototype.onHit = function(c, e, solid) {
      var _ref;
      if (e.type === 'Player' && e.playerType === this.ent.playerType && !this.armed) {
        if (this.hitCount !== this.updateCount) {
          this.hitCount = 0;
          this.updateCount = 0;
        }
        return this.hitCount++;
      } else if ((((_ref = e.type) === 'Laser' || _ref === 'Explosion' || _ref === 'Bomb') || (e.type === 'Player' && !e.invincible)) && this.armed && solid) {
        return this.boom();
      } else if ((this.xBounce || this.yBounce) && solid) {
        if (this.yBounce) {
          if (c.bottom) {
            this.direction.y = -1;
          } else if (c.top) {
            this.direction.y = 1;
          }
        }
        if (this.xBounce) {
          if (c.right) {
            return this.direction.x = -1;
          } else if (c.left) {
            return this.direction.x = 1;
          }
        }
      }
    };

    Bomb.prototype.draw = function(ctx) {
      if (!this.explode.exploding) {
        ctx.save().fillStyle(colors.bomb.background).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
        if (this.xBounce) {
          ctx.save().fillStyle(this.armed ? colors.bomb.on : colors.bomb.off).fillRect(Math.round(this.x), Math.round(this.y + 2), this.width, this.height - 4).restore();
        }
        if (this.yBounce) {
          ctx.save().fillStyle(this.armed ? colors.bomb.on : colors.bomb.off).fillRect(Math.round(this.x + 2), Math.round(this.y), this.width - 4, this.height).restore();
        }
        return ctx.save().fillStyle(this.armed ? colors.bomb.on : colors.bomb.off).fillRect(Math.round(this.x + 1), Math.round(this.y + 1), this.width - 2, this.height - 2).restore();
      } else {
        return ctx.save().fillStyle(this.explode.color).fillRect(Math.round(this.x - this.explode.size / 2), Math.round(this.y - this.explode.size / 2), this.explode.size, this.explode.size).restore();
      }
    };

    return Bomb;

  })();

  entity.Slime = (function() {
    function Slime(_at_level, _at_height) {
      var randomBloop;
      this.level = _at_level;
      this.height = _at_height != null ? _at_height : 0;
      this.type = 'Slime';
      this.x = 0;
      this.y = this.level.height - this.height;
      this.width = this.level.width;
      this.cache = {};
      randomBloop = (function(_this) {
        return function() {
          return setFrameTimeout(function() {
            var height, width;
            _this.bloops.push({
              width: width = Math.round(6 * Math.random()) + 7,
              maxHeight: height = Math.round(8 * Math.random()) + 8,
              x: Math.round((level.width + width) * Math.random()) - width / 2,
              growthDir: 1,
              height: 1,
              speed: ((height / 12) * 0.8) * (Math.round(Math.random() + 1.5))
            });
            return randomBloop();
          }, Math.round(800 * Math.random()) + 2000);
        };
      })(this);
      randomBloop();
    }

    Slime.prototype.vel = {
      x: 0,
      y: 0
    };

    Slime.prototype.bloops = [];

    Slime.prototype.isSolidTo = function(ent) {
      return true;
    };

    Slime.prototype.update = function() {
      var bloop, easing, heightDelta, i, widthDelta, _ref, _results;
      this.y = level.height - this.height + 1;
      applyPhysics(this);
      _ref = this.bloops;
      _results = [];
      for (i in _ref) {
        bloop = _ref[i];
        if (bloop.height < 1) {
          _results.push(this.bloops.splice(i, 1));
        } else {
          easing = 1 - bloop.height / bloop.maxHeight;
          if (bloop.growthDir > 0) {
            widthDelta = (bloop.width / 10) * (bloop.height / bloop.maxHeight);
            bloop.width -= widthDelta;
            bloop.x += widthDelta / 2;
          }
          heightDelta = bloop.speed * easing * bloop.growthDir;
          bloop.height += heightDelta;
          if (bloop.height >= bloop.maxHeight - 1) {
            _results.push(bloop.growthDir = -1);
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Slime.prototype.onHit = function(col, ent) {
      var height, _ref;
      if (((_ref = ent.type) === 'Bomb' || _ref === 'Item') || (ent.type === 'Player' && !ent.invincible)) {
        this.bloops.push({
          x: ent.x,
          width: ent.width,
          maxHeight: height = ent.height * 1.5,
          growthDir: 1,
          height: 1,
          speed: ((height / 12) * 0.8) * (Math.round(Math.random() + 1.5))
        });
        if (!ent.cache.burning) {
          if (ent.type === 'Player') {
            ent.die();
          }
          if (ent.type === 'Bomb') {
            if (typeof ent.boom === "function") {
              ent.boom();
            }
          }
          if (ent.type === 'Item') {
            if (typeof ent.destroy === "function") {
              ent.destroy();
            }
          }
          if (ent.width > 4) {
            sound.play('burn_large');
          } else {
            sound.play('burn_small');
          }
          if (ent.type !== 'Player') {
            return ent.cache.burning = true;
          }
        }
      }
    };

    Slime.prototype.draw = function(ctx) {
      var bloop, _i, _len, _ref;
      ctx.save().globalAlpha(0.9).fillStyle(colors.slime.main).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
      _ref = this.bloops;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bloop = _ref[_i];
        ctx.fillRect(Math.round(bloop.x), Math.round(this.y - bloop.height), Math.round(bloop.width), Math.round(bloop.height + 1));
      }
      return ctx.restore();
    };

    return Slime;

  })();

  Item = (function() {
    function Item() {}

    Item.prototype.type = 'Item';

    Item.prototype.color = colors.item;

    Item.prototype.x = 0;

    Item.prototype.y = 0;

    Item.prototype.width = 5;

    Item.prototype.height = 5;

    Item.prototype.alpha = 1;

    Item.prototype.speed = 10;

    Item.prototype.applyToOpponent = false;

    Item.prototype.flyToSpawn = false;

    Item.prototype.player = void 0;

    Item.prototype.flyToPlayerAndApply = function() {
      var delta, direction, obj;
      if (this.player != null) {
        this.alpha = 0.5;
        obj = this.flyToSpawn ? this.player.spawn : this.player;
        delta = {
          x: (obj.x + obj.width / 2) - (this.x + this.width / 2),
          y: (obj.y + obj.height / 2) - (this.y + this.height / 2)
        };
        direction = {
          x: Math.round(delta.x) > 0 ? 1 : -1,
          y: Math.round(delta.y) > 0 ? 1 : -1
        };
        this.x += Math.min(this.speed, Math.abs(delta.x)) * direction.x;
        this.y += Math.min(this.speed, Math.abs(delta.y)) * direction.y;
        if (hasBoxHit(Math.round(this.x), Math.round(this.y), this.width, this.height, Math.round(obj.x), Math.round(obj.y), obj.width, obj.height)) {
          sound.play('blop');
          this.applyItem(this.player);
          return this.destroy();
        }
      }
    };

    Item.prototype.onHit = function(col, ent) {
      if (ent.type === 'Player' && (this.player == null)) {
        return this.player = this.applyToOpponent ? ent.other : ent;
      }
    };

    Item.prototype.applyItem = function(player) {};

    Item.prototype.destroy = function() {
      var _ref, _ref1, _ref2;
      if ((_ref = this.spawner) != null) {
        _ref.itemCount--;
      }
      if ((_ref1 = this.container) != null) {
        _ref1[this.key] = void 0;
      }
      return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
    };

    Item.prototype.update = function() {
      return this.flyToPlayerAndApply();
    };

    Item.prototype.draw = function(ctx) {
      return ctx.save().fillStyle(this.color).globalAlpha(this.alpha).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Item;

  })();

  Item_Spawner = (function() {
    function Item_Spawner(_at_destination, _at_itemTypes, _at_width, _at_height, _at_itemLimit) {
      this.destination = _at_destination;
      this.itemTypes = _at_itemTypes;
      this.width = _at_width;
      this.height = _at_height;
      this.itemLimit = _at_itemLimit != null ? _at_itemLimit : 10;
      this.spawnNewItem = __bind(this.spawnNewItem, this);
      this.setSpawnTimer();
    }

    Item_Spawner.prototype.itemCount = 0;

    Item_Spawner.prototype.itemIdCount = 0;

    Item_Spawner.prototype.setSpawnTimer = function() {
      var maxTime, minTime, time;
      minTime = 100;
      maxTime = 5000;
      time = typeof devTime !== "undefined" && devTime !== null ? devTime : Math.round(Math.random() * minTime) + maxTime;
      return setFrameTimeout((function(_this) {
        return function() {
          _this.spawnNewItem();
          return _this.setSpawnTimer();
        };
      })(this), time);
    };

    Item_Spawner.prototype.spawnNewItem = function() {
      var abort, args, generateLocation, i, itemType, itemTypeIndex, key, maxTries, newItem, tries, x, y;
      if (this.itemCount !== this.itemLimit) {
        this.itemCount++;
        this.itemIdCount++;
        key = "Level_Item_" + this.itemIdCount;
        itemTypeIndex = Math.round(Math.random() * (this.itemTypes.length - 1));
        itemType = this.itemTypes[itemTypeIndex];
        args = [];
        if (itemType instanceof Array) {
          i = itemType[0];
          args = itemType.slice(1);
          itemType = i;
        }
        newItem = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(item[itemType], [this.destination, key, this].concat(__slice.call(args)), function(){});
        maxTries = 10;
        tries = 0;
        abort = false;
        x = 0;
        y = 0;
        generateLocation = (function(_this) {
          return function() {
            var col, ent, entSource, noCol, oh, ow, ox, oy, _i, _len, _ref;
            x = Math.round(Math.random() * _this.width);
            y = Math.round(Math.random() * _this.height);
            noCol = true;
            _ref = [_this.destination, players];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entSource = _ref[_i];
              for (i in entSource) {
                ent = entSource[i];
                ox = ent.x;
                ow = ent.width;
                oy = ent.x;
                oh = ent.height;
                if (col = hasBoxHit(x, y, newItem.width, newItem.height, ent.x, ent.y, ent.width, ent.height)) {
                  noCol = false;
                }
              }
            }
            if (!noCol) {
              if (tries++ !== maxTries - 1) {
                return generateLocation();
              } else {
                return abort = true;
              }
            }
          };
        })(this);
        generateLocation();
        if (!abort) {
          newItem.x = x;
          newItem.y = y;
          return this.destination[key] = newItem;
        }
      }
    };

    return Item_Spawner;

  })();

  item.AddLife = (function(_super) {
    __extends(AddLife, _super);

    function AddLife(_at_container, _at_key, _at_spawner) {
      this.container = _at_container;
      this.key = _at_key;
      this.spawner = _at_spawner;
    }

    AddLife.prototype.color = colors.life;

    AddLife.prototype.flyToSpawn = true;

    AddLife.prototype.onHit = function(col, ent) {
      if (ent.type === 'Player' && ent.lives !== ent.maxLives) {
        return AddLife.__super__.onHit.call(this, col, ent);
      }
    };

    AddLife.prototype.applyItem = function(player) {
      player.lives++;
      return level != null ? level.addBlinkUpdate(player.spawn.x + player.spawn.width / 2, player.spawn.y, '+1', false) : void 0;
    };

    return AddLife;

  })(Item);

  item.NoWingsEnemy = (function(_super) {
    __extends(NoWingsEnemy, _super);

    function NoWingsEnemy(_at_container, _at_key, _at_spawner) {
      this.container = _at_container;
      this.key = _at_key;
      this.spawner = _at_spawner;
    }

    NoWingsEnemy.prototype.color = colors.noWingsEnemy;

    NoWingsEnemy.prototype.applyToOpponent = true;

    NoWingsEnemy.prototype.applyItem = function(player) {
      return player.addEffect('NoWingsEnemy', function() {
        var _base;
        if (player.cache.noWingsEnemy == null) {
          player.cache.noWingsEnemy = {
            yForce: player.yForce
          };
          player.yForce = 0;
          removePlayerVelocity(player.playerType, 'up');
          return (_base = player.subEntities).noWingsEnemy != null ? _base.noWingsEnemy : _base.noWingsEnemy = {
            color: colors.noWingsEnemy,
            alpha: 0.5,
            margin: 2,
            update: function() {},
            draw: function(ctx) {
              return ctx.save().fillStyle(this.color).globalAlpha(this.alpha).fillRect(Math.round(player.x - this.margin), Math.round(player.y - this.margin), player.width + this.margin * 2, player.height + this.margin * 2).restore();
            }
          };
        }
      }, function() {
        if (player.cache.noWingsEnemy != null) {
          player.yForce = player.cache.noWingsEnemy.yForce;
          delete player.cache.noWingsEnemy;
          return delete player.subEntities.noWingsEnemy;
        }
      }, 4000);
    };

    return NoWingsEnemy;

  })(Item);

  bombId = 0;

  item.Bomb = (function(_super) {
    __extends(Bomb, _super);

    function Bomb(_at_container, _at_key, _at_spawner, _at_xBounce, _at_yBounce) {
      this.container = _at_container;
      this.key = _at_key;
      this.spawner = _at_spawner;
      this.xBounce = _at_xBounce;
      this.yBounce = _at_yBounce;
    }

    Bomb.prototype.color = colors.bomb.background;

    Bomb.prototype.onHit = function(col, ent) {
      if (ent.type === 'Player' && (ent.item == null)) {
        return Bomb.__super__.onHit.call(this, col, ent);
      }
    };

    Bomb.prototype.applyItem = function(player) {
      if (player.item == null) {
        return player.item = {
          use: (function(_this) {
            return function() {
              var key;
              if (!hasBoxHit(player.x + player.width / 2 - 3, player.y + player.height / 2 - 3, 6, 6, player.spawn.x, player.spawn.y, player.spawn.width, player.spawn.height)) {
                player.item = void 0;
                key = player.playerType + "_bomb-" + (bombId++);
                sound.play('placeBomb');
                return level.midground[key] = new entity.Bomb(player, key, _this.xBounce, _this.yBounce);
              }
            };
          })(this),
          draw: (function(_this) {
            return function(ctx) {
              var height, width;
              width = 5;
              height = 5;
              ctx.save().fillStyle(_this.color).fillRect(Math.round(player.x + (player.width - width) / 2), Math.round(player.y + (player.height - height) / 2), width, height).restore();
              if (_this.xBounce) {
                ctx.save().fillStyle(colors.bomb.off).fillRect(Math.round(player.x + (player.width - width) / 2), Math.round(player.y + (player.height - height) / 2 + 2), width, height - 4).restore();
              }
              if (_this.yBounce) {
                return ctx.save().fillStyle(colors.bomb.off).fillRect(Math.round(player.x + (player.width - width) / 2 + 2), Math.round(player.y + (player.height - height) / 2), width - 4, height).restore();
              }
            };
          })(this)
        };
      }
    };

    Bomb.prototype.draw = function(ctx) {
      Bomb.__super__.draw.call(this, ctx);
      if (this.xBounce) {
        ctx.save().fillStyle(colors.bomb.off).fillRect(Math.round(this.x), Math.round(this.y + 2), this.width, this.height - 4).restore();
      }
      if (this.yBounce) {
        return ctx.save().fillStyle(colors.bomb.off).fillRect(Math.round(this.x + 2), Math.round(this.y), this.width - 4, this.height).restore();
      }
    };

    return Bomb;

  })(Item);

  levels.level_middle = {
    type: 'Map',
    name: 'middle',
    x: 0,
    y: 0,
    width: 300,
    height: 200,
    offsetX: 0,
    offsetY: 0,
    winner: '',
    render: cq(),
    onEnd: function(type) {
      return console.log('ENDS');
    },
    onBuild: function() {
      var ent, i, ii, source, vars, _ref, _results;
      vars = {};
      this.midground = {
        top: new entity.Boundary(0, 0, 300, 4),
        bottom: new entity.Boundary(0, 196, 300, 4),
        left: new entity.Boundary(0, 0, 4, 200),
        right: new entity.Boundary(296, 0, 4, 200),
        spawn_red: new entity.PlayerSpawn(50, 52, 'Red'),
        spawn_blue: new entity.PlayerSpawn(230, 52, 'Blue'),
        row1_left: new entity.Boundary(40, 55, 60, 4),
        row1_right: new entity.Boundary(200, 55, 60, 4),
        row1_barrier_middle: new entity.Boundary(148, 50, 4, 25),
        row1_barrier_right: new entity.Boundary(200, 59, 4, 15),
        row1_barrier_left: new entity.Boundary(96, 59, 4, 15),
        row2_middle: new entity.Boundary(115, 110, 70, 4),
        row2_left: new entity.Boundary(30, 110, 50, 4),
        row2_right: new entity.Boundary(220, 110, 50, 4),
        laser_1_right: new entity.Laser(152, 55, 48, 15, false, '#21b2b4'),
        laser_1_left: new entity.Laser(100, 55, 48, 15, false, '#21b2b4'),
        laser_1_button: new entity.Button(148, 108, function() {
          level.midground.laser_1_right.on = true;
          return level.midground.laser_1_left.on = true;
        }, function() {
          level.midground.laser_1_right.on = false;
          return level.midground.laser_1_left.on = false;
        }, true, '#21b2b4'),
        laser_2_middle: new entity.Laser(148, 4, 4, 46, false),
        laser_2_right_button: new entity.Button(204, 53, function() {
          return vars.laser_2_right_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_right_button = false;
          if (!vars.laser_2_left_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true),
        laser_2_left_button: new entity.Button(92, 53, function() {
          return vars.laser_2_left_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_left_button = false;
          if (!vars.laser_2_right_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true),
        slime: new entity.Slime(this, 23)
      };
      this.spawner = new Item_Spawner(this.midground, ['Bomb', ['Bomb', true, false], ['Bomb', false, true], ['Bomb', true, true], 'NoWingsEnemy', 'AddLife'], this.width, this.height, 10);
      _ref = [players, this.midground, this.foreground];
      _results = [];
      for (i in _ref) {
        source = _ref[i];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (ii in source) {
            ent = source[ii];
            _results1.push(ent != null ? typeof ent.onBuild === "function" ? ent.onBuild(this) : void 0 : void 0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    shake: {
      shaking: false,
      speed: 3,
      dir: {
        x: 1,
        y: 1
      },
      dist: {
        x: 6,
        y: 3
      },
      timeout: {},
      start: function(duration) {
        if (duration == null) {
          duration = 300;
        }
        if (typeof this.timeout === "function") {
          this.timeout();
        }
        this.shaking = true;
        return this.timeout = setFrameTimeout((function(_this) {
          return function() {
            return _this.shaking = false;
          };
        })(this), duration);
      },
      update: function() {
        if (this.shaking) {
          if (Math.abs(level.offsetX) >= this.dist.x) {
            this.dir.x *= -1;
          }
          if (Math.abs(level.offsetY) >= this.dist.y) {
            this.dir.y *= -1;
          }
          level.offsetX += this.speed * this.dir.x;
          return level.offsetY += this.speed * this.dir.y;
        } else {
          level.offsetX = 0;
          return level.offsetY = 0;
        }
      }
    },
    blinkUpdates: [],
    addBlinkUpdate: function(x, y, text, red) {
      return this.blinkUpdates.push({
        x: Math.round(x),
        y: Math.round(y),
        text: text,
        alpha: 1,
        red: red,
        container: this.blinkUpdates,
        update: function() {
          this.y -= 0.8;
          this.alpha -= 0.02;
          if (this.alpha <= 0) {
            return this.container.splice(this.container.indexOf(this), 1);
          }
        },
        draw: function(ctx) {
          return ctx.save().globalAlpha(this.alpha).font('Helvetica').textBaseline('top').textAlign('center').fillStyle(this.red ? '#e00005' : '#79df06').fillText(this.text, this.x, this.y).restore();
        }
      });
    },
    update: function() {
      var update, _i, _len, _ref, _results;
      this.render.canvas.width = this.width;
      this.render.canvas.height = this.height;
      if (players.blue.lives === 0) {
        this.winner = 'Red';
      }
      if (players.red.lives === 0) {
        this.winner = 'Blue';
      }
      if (players.red.lives === 0 && players.blue.lives === 0) {
        this.winner = 'draw';
      }
      level.shake.update();
      _ref = this.blinkUpdates;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        update = _ref[_i];
        _results.push(update != null ? update.update() : void 0);
      }
      return _results;
    },
    drawBackground: function() {
      return this.render.save().fillStyle('#383838').fillRect(0, 0, this.width, this.height).restore();
    },
    drawMidground: function() {
      var ent, i, _ref;
      this.render.save();
      _ref = this.midground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      return this.render.restore();
    },
    drawForeground: function() {
      var ent, i, update, _i, _len, _ref, _ref1, _results;
      this.render.save();
      _ref = this.foreground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      this.render.restore();
      _ref1 = this.blinkUpdates;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        update = _ref1[_i];
        _results.push(update.draw(this.render));
      }
      return _results;
    },
    reset: function() {
      var ent, name, _ref;
      console.log(this);
      _ref = this.midground;
      for (name in _ref) {
        ent = _ref[name];
        delete this.midground;
      }
      delete this.spawner;
      clearFrameTimeouts();
      this.winner = '';
      return this.onBuild();
    }
  };

  Player = (function() {
    function Player(_at_playerType, _at_color, controlScheme, _at_direction) {
      var player, playerType;
      this.playerType = _at_playerType;
      this.color = _at_color;
      this.direction = _at_direction != null ? _at_direction : -1;
      this.onHit = __bind(this.onHit, this);
      this.x = 0;
      this.y = 0;
      this.width = 7;
      this.height = 12;
      this.xForce = 1.7;
      this.yForce = 2;
      this.spawn = void 0;
      this.item = void 0;
      this.cache = {};
      this.subEntities = {};
      this.vel = {
        x: 0,
        y: 0,
        mod: {
          gravity: {
            x: 0,
            y: 0
          }
        }
      };
      ({
        pause: false
      });
      this.effects = {};
      this.item = void 0;
      this.invincibleTimeout = function() {};
      this.onBuild = function(level) {
        this.other = players[playerType === 'red' ? 'blue' : 'red'];
        this.maxLives = 10;
        return this.lives = this.maxLives - 3;
      };
      playerType = this.playerType;
      player = this;
      this.keys = {};
      this.keys[controlScheme.up] = {
        press: function() {
          addPlayerVelocity(playerType, 'up', {
            y: -player.yForce
          });
          if (player.vel.mod.punch_down != null) {
            player.vel.mod.punch_down.y -= player.yForce / 8;
          }
          player.vel.mod.gravity.y = 0;
          return sound.play('flap');
        }
      };
      this.keys[controlScheme.down] = {
        press: function() {
          return removePlayerVelocity(playerType, 'up');
        }
      };
      this.keys[controlScheme.left] = {
        press: function() {
          var _ref;
          player.direction = -1;
          addPlayerVelocity(playerType, 'left', {
            x: -player.xForce
          });
          if ((_ref = player.vel.mod.punch_left) != null ? _ref.x : void 0) {
            return player.vel.mod.punch_left.x -= player.xForce / 4;
          }
        },
        release: function() {
          return removePlayerVelocity(playerType, 'left');
        }
      };
      this.keys[controlScheme.right] = {
        press: function() {
          var _ref;
          player.direction = 1;
          addPlayerVelocity(playerType, 'right', {
            x: player.xForce
          });
          if ((_ref = player.vel.mod.punch_right) != null ? _ref.x : void 0) {
            return player.vel.mod.punch_right.x += player.xForce / 4;
          }
        },
        release: function() {
          return removePlayerVelocity(playerType, 'right');
        }
      };
      this.keys[controlScheme.item] = {
        press: function() {
          return player.useItem();
        }
      };
    }

    Player.prototype.type = 'Player';

    Player.prototype.isSolidTo = function() {
      return true;
    };

    Player.prototype.useItem = function() {
      var _ref;
      return (_ref = this.item) != null ? _ref.use() : void 0;
    };

    Player.prototype.removeAllEffects = function() {
      var effect, name, _ref, _results;
      _ref = this.effects;
      _results = [];
      for (name in _ref) {
        effect = _ref[name];
        _results.push(this.removeEffect(name));
      }
      return _results;
    };

    Player.prototype.removeEffect = function(name) {
      if (this.effects[name] != null) {
        this.effects[name].timeout();
        this.effects[name].remove();
        this.effects[name] = void 0;
        return delete this.effects[name];
      }
    };

    Player.prototype.addEffect = function(name, add, remove, time) {
      var _ref;
      if ((_ref = this.effects[name]) != null) {
        _ref.timeout();
      }
      remove();
      add();
      return this.effects[name] = {
        remove: remove,
        timeout: setFrameTimeout((function(_this) {
          return function() {
            remove();
            _this.effects[name] = void 0;
            return delete _this.effects[name];
          };
        })(this), time)
      };
    };

    Player.prototype.onHit = function(c, e, solid) {
      var _ref, _ref1, _ref2, _ref3, _ref4;
      if (solid) {
        if (c.top) {
          if ((_ref = this.vel.mod.up) != null) {
            _ref.y = 0;
          }
        }
        if (c.bottom) {
          this.vel.mod.gravity.y = 0;
          if ((_ref1 = this.vel.mod.punch_down) != null) {
            _ref1.y = 0;
          }
          if (!((_ref2 = this.keys.w) != null ? _ref2.pressed : void 0)) {
            removePlayerVelocity(this.playerType, 'up');
          }
        }
        if (c.bottom || c.top) {
          if (this.vel.mod.punch_right != null) {
            if ((_ref3 = this.vel.mod.punch_right) != null ? _ref3.x : void 0) {
              this.vel.mod.punch_right.x += 0.05;
            }
          }
          if (this.vel.mod.punch_left != null) {
            if ((_ref4 = this.vel.mod.punch_left) != null ? _ref4.x : void 0) {
              this.vel.mod.punch_left.x -= 0.05;
            }
          }
        }
        if (c.left) {
          removePlayerVelocity(this.playerType, 'punch_right');
        }
        if (c.right) {
          removePlayerVelocity(this.playerType, 'punch_left');
        }
        if (e.type === 'Player' && !e.invincible) {
          if (this.vel.y > 1 && c.bottom) {
            sound.play('pop');
            return addPlayerVelocity(e.playerType, 'punch_down', {
              y: this.vel.y
            });
          } else if (this.vel.x > 1 && c.right) {
            sound.play('pop');
            addPlayerVelocity(e.playerType, 'punch_left', {
              x: this.vel.x
            });
            return removePlayerVelocity(this.playerType, 'right');
          } else if (this.vel.x < -1 && c.left) {
            sound.play('pop');
            addPlayerVelocity(e.playerType, 'punch_right', {
              x: this.vel.x
            });
            return removePlayerVelocity(this.playerType, 'left');
          }
        }
      }
    };

    Player.prototype.update = function() {
      var mod, name, subEnt, _ref, _ref1, _ref2, _ref3, _ref4;
      if (!this.pause) {
        this.vel.mod.gravity.y += gravity;
        this.vel.x = 0;
        this.vel.y = 0;
        if (((_ref = this.vel.mod.punch_right) != null ? _ref.x : void 0) > 0) {
          removePlayerVelocity(this.playerType, 'punch_right');
        }
        if (((_ref1 = this.vel.mod.punch_left) != null ? _ref1.x : void 0) < 0) {
          removePlayerVelocity(this.playerType, 'punch_left');
        }
        if (((_ref2 = this.vel.mod.punch_down) != null ? _ref2.y : void 0) < 0) {
          removePlayerVelocity(this.playerType, 'punch_down');
        }
        _ref3 = this.vel.mod;
        for (name in _ref3) {
          mod = _ref3[name];
          if (mod.x) {
            this.vel.x += mod.x;
          }
          if (mod.y) {
            this.vel.y += mod.y;
          }
        }
        _ref4 = this.subEntities;
        for (name in _ref4) {
          subEnt = _ref4[name];
          if (typeof subEnt.update === "function") {
            subEnt.update();
          }
        }
      }
      return applyPhysics(this);
    };

    Player.prototype.die = function(before, after) {
      if (!this.invincible) {
        if (typeof before === "function") {
          before();
        }
        if (level != null) {
          level.addBlinkUpdate(this.spawn.x + this.spawn.width / 2, this.spawn.y, '-1', true);
        }
        this.removeAllEffects();
        this.lives--;
        this.vel = {
          x: 0,
          y: 0,
          mod: {
            gravity: {
              x: 0,
              y: 0
            }
          }
        };
        this.spawn.reset();
        return typeof after === "function" ? after() : void 0;
      }
    };

    Player.prototype.draw = function(ctx, delta, time) {
      var name, subEnt, _ref;
      if (level != null) {
        ctx.save().fillStyle(colors.playerFlesh).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y + 8), this.width, 2).fillRect(Math.round(this.x + 2 + (1 * this.direction)), Math.round(this.y + 10), 3, 2);
        if (this.item != null) {
          if (this.item.draw != null) {
            this.item.draw(ctx);
          } else {
            ctx.fillStyle(this.item.color).fillRect(Math.round(this.x + this.width / 2 - 2), Math.round(this.y + this.height / 2 - 2), 4, 4);
          }
        }
        _ref = this.subEntities;
        for (name in _ref) {
          subEnt = _ref[name];
          if (typeof subEnt.draw === "function") {
            subEnt.draw(ctx, delta, time);
          }
        }
        ctx.restore();
        if (this.invincible) {
          return ctx.save().globalAlpha(0.5).fillStyle(colors.invincible).fillRect(Math.round(this.x - 1), Math.round(this.y - 1), this.width + 2, this.height + 2).restore();
        }
      }
    };

    return Player;

  })();

  players.blue = new Player('blue', colors.players.blue, {
    up: 'up',
    down: 'down',
    left: 'left',
    right: 'right',
    item: 'period'
  });

  players.red = new Player('red', colors.players.red, {
    up: 'w',
    down: 's',
    left: 'a',
    right: 'd',
    item: 'g'
  }, 1);

  touchMove = false;

  touchTimeout = {};

  this.mouse = mouse = {
    x: 0,
    y: 0,
    down: false,
    up: false
  };

  gameCq = cq().framework({
    onresize: function(width, height) {
      if (mouse.x > width) {
        mouse.x = width;
      }
      if (mouse.y > height) {
        mouse.y = height;
      }
      this.canvas.width = width;
      this.canvas.height = height;
    },
    onmouseup: mouseUpHandler = function(x, y, btn) {
      mouse.down = false;
      return mouse.up = true;
    },
    onmousedown: mouseDownHandler = function(x, y, btn) {
      return mouse.down = true;
    },
    onmousemove: mouseMoveHandler = function(x, y) {
      mouse.x = x;
      return mouse.y = y;
    },
    ontouchstart: function(x, y, touch) {
      if (touch.length === 1) {
        touchDown = true;
        return mouseMoveHandler(x, y);
      }
    },
    ontouchmove: function(x, y, touch) {
      touchMove = true;
      return mouseMoveHandler(x, y);
    },
    ontouchend: function(x, y, touch) {
      touchDown = false;
      if (!touchMove) {
        mouseDownHandler(x, y);
        touchTimeout();
        touchTimeout = setFrameTimeout(function() {
          return mouseUpHandler(x, y);
        }, 100);
      }
      return touchMove = false;
    },
    onkeydown: function(key, e) {
      var name, player, _base, _results;
      if (gameKeys[key] != null) {
        gameKeys[key]();
      }
      if (level != null ? level.winner : void 0) {
        return level.reset();
      } else {
        _results = [];
        for (name in players) {
          player = players[name];
          if ((player.keys[key] != null) && !player.keys[key].pressed) {
            player.keys[key].pressed = true;
            _results.push(typeof (_base = player.keys[key]).press === "function" ? _base.press() : void 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    },
    onkeyup: function(key) {
      var name, player, _base, _results;
      _results = [];
      for (name in players) {
        player = players[name];
        if ((player.keys[key] != null) && player.keys[key].pressed) {
          player.keys[key].pressed = false;
          _results.push(typeof (_base = player.keys[key]).release === "function" ? _base.release() : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    onrender: function(delta, time) {
      var loadingBar, name, player;
      this.clear('#202424');
      this.context.mozImageSmoothingEnabled = this.context.webkitImageSmoothingEnabled = this.context.msImageSmoothingEnabled = this.context.imageSmoothingEnabled = false;
      if (!loaded) {
        this.fillStyle('white');
        loadingBar = {
          width: this.canvas.width / 2,
          margin: this.canvas.width / 4
        };
        loadingBar.sectionWidth = loadingBar.width / soundsToLoad.length;
        this.save().globalAlpha(0.5).fillRect(loadingBar.margin, this.canvas.height / 2 - 50, loadingBar.width, 100).restore();
        this.save().globalAlpha(1).fillRect(loadingBar.margin, this.canvas.height / 2 - 50, loadingBar.sectionWidth * soundsLoadedCount, 100).restore();
        this.restore();
      } else if (level != null) {
        level.render.context.mozImageSmoothingEnabled = level.render.context.webkitImageSmoothingEnabled = level.render.context.msImageSmoothingEnabled = level.render.context.imageSmoothingEnabled = false;
        resizeFactor = Math.min(gameCanvas.width / level.width, gameCanvas.height / (level.height + 20));
        updateFrameTimeouts();
        if (typeof level.update === "function") {
          level.update();
        }
        if (!level.winner) {
          if (typeof level.drawBackground === "function") {
            level.drawBackground();
          }
          for (name in players) {
            player = players[name];
            if (typeof player.update === "function") {
              player.update();
            }
            if (typeof player.draw === "function") {
              player.draw(level.render, delta, time);
            }
          }
          if (typeof level.drawMidground === "function") {
            level.drawMidground();
          }
          if (typeof level.drawForeground === "function") {
            level.drawForeground();
          }
        } else {
          level.render.save().font('2em Helvetica').textAlign('center').textBaseline('middle');
          if (level.winner === 'draw') {
            level.render.fillStyle(colors.life).wrappedText("It was a draw!", level.width / 2, level.height / 2 - 20, level.width);
          } else {
            level.render.fillStyle(players[level.winner.toLowerCase()].color).wrappedText(level.winner + " won!", level.width / 2, level.height / 2 - 20, level.width);
          }
          level.render.fillStyle('white').font('1em Helvetica').wrappedText("press any key to play again", level.width / 2, level.height / 2 + 10, level.width);
          level.render.restore();
        }
        this.save().translate((gameCanvas.width / 2 + level.offsetX) - (level.width * resizeFactor) / 2, (gameCanvas.height / 2 + level.offsetY) - (level.height * resizeFactor) / 2).drawImage(level.render.canvas, 0, 0, level.width * resizeFactor, level.height * resizeFactor).restore();
      }
      mouse.up = false;
    }
  });

  gameCanvas = gameCq.canvas;

  gameCq.appendTo('body');

  gameCanvas.width = root.innerWidth;

  gameCanvas.height = root.innerHeight;

  onEvent('assetsLoaded', function() {
    gameMusic = sound.play('gameMusic', void 0, void 0, void 0, -1);
    loadLevel('middle');
    mouse.x = gameCanvas.width / 2;
    mouse.y = gameCanvas.height / 2;
    mouse.up = false;
    return mouse.down = false;
  });

}).call(this);
