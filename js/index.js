// Generated by CoffeeScript 1.7.1
(function() {
  var Boundary, Button, HUD, Item_Spawner, Laser, Player, PlayerSpawn, addPlayerVelocity, bombId, events, fireEvent, frame, gameCanvas, gameCq, gravity, hasBoxHit, hasMouseHit, items, level, levels, loadLevel, loaded, mouse, mouseDownHandler, mouseMoveHandler, mouseUpHandler, onEvent, playerHitsAndVelocity, players, removePlayerVelocity, resizeFactor, root, touchDown, touchMove, touchTimeout,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = this;

  loaded = false;

  frame = 0;

  touchDown = false;

  this.levels = levels = {};

  this.players = players = {};

  this.items = items = {};

  this.HUD = HUD = [];

  this.level = level = void 0;

  resizeFactor = 2;

  gravity = 0.1;

  events = {};

  onEvent = function(eventName, eventHandler) {
    if (events[eventName] == null) {
      events[eventName] = [];
    }
    events[eventName].push(eventHandler);
    return function() {
      return events[eventName].splice(events[eventName].indexOf(eventHandler), 1);
    };
  };

  fireEvent = function() {
    var args, eventHandler, eventName, _i, _len, _ref, _ref1, _results;
    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((_ref = events[eventName]) != null ? _ref.length : void 0) {
      _ref1 = events[eventName];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        eventHandler = _ref1[_i];
        _results.push(eventHandler.apply(null, args));
      }
      return _results;
    }
  };

  setTimeout(function() {
    return fireEvent('assetsLoaded');
  });

  'use strict';

  hasMouseHit = function(x, y, width, height) {
    var col;
    col = {
      x: x + width / 2 >= mouse.x && x - width / 2 <= mouse.x,
      y: y + height / 2 >= mouse.y && y - height / 2 <= mouse.y
    };
    if (col.x && col.y) {
      return true;
    } else {
      return false;
    }
  };

  hasBoxHit = function(_ax, _ay, _awidth, _aheight, _bx, _by, _bwidth, _bheight) {
    var aX, aXX, aY, aYY, bX, bXX, bY, bYY, col;
    aX = _ax;
    aXX = _ax + _awidth;
    aY = _ay;
    aYY = _ay + _aheight;
    bX = _bx;
    bXX = _bx + _bwidth;
    bY = _by;
    bYY = _by + _bheight;
    col = {
      x: (aX >= bX && aX <= bXX || aXX >= bX && aXX <= bXX) || (bX >= aX && bX <= aXX || bXX >= aX && bXX <= aXX),
      y: (aY >= bY && aY <= bYY || aYY >= bY && aYY <= bYY) || (bY >= aY && bY <= aYY || bYY >= aY && bYY <= aYY)
    };
    if (col.x && col.y) {
      return {
        left: aX >= bX && aX <= bXX,
        right: aXX >= bX && aXX <= bXX,
        top: aY >= bY && aY <= bYY,
        bottom: aYY >= bY && aYY <= bYY
      };
    } else {
      return false;
    }
  };

  loadLevel = (function(_this) {
    return function(name) {
      root.level = level = levels["level_" + name] || {};
      return typeof level.onBuild === "function" ? level.onBuild() : void 0;
    };
  })(this);

  addPlayerVelocity = function(player, name, vector) {
    players[player].vel.mod[name] = {};
    if (vector.x) {
      players[player].vel.mod[name].x = vector.x;
    }
    if (vector.y) {
      return players[player].vel.mod[name].y = vector.y;
    }
  };

  removePlayerVelocity = function(player, name) {
    return delete players[player].vel.mod[name];
  };

  playerHitsAndVelocity = function(player) {
    var col, collisions, correction, ent, entSource, i, oh, ow, ox, oy, solid, xCorrection, xDepth, yCorrection, yDepth, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    xCorrection = 1;
    yCorrection = 1;
    _ref = [level != null ? level.midground : void 0, [player.other]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entSource = _ref[_i];
      for (i in entSource) {
        ent = entSource[i];
        ox = ent.x;
        ow = ent.width;
        oy = ent.x;
        oh = ent.height;
        if (col = hasBoxHit(player.x + player.vel.x, player.y + player.vel.y, player.width, player.height, ent.x, ent.y, ent.width, ent.height)) {
          solid = ent.solid || (typeof ent.isSolidTo === "function" ? ent.isSolidTo(player) : void 0);
          xDepth = 0;
          yDepth = 0;
          if (col.left && col.right) {
            xDepth = player.width;
          } else if (!col.left && !col.right) {
            xDepth = ent.width;
          } else if (col.left && !col.right) {
            xDepth = player.width - ((player.x + player.vel.x + player.width) - (ent.x + ent.width));
          } else if (!col.left && col.right) {
            xDepth = player.width - (ent.x - (player.x + player.vel.x));
          }
          if (col.top && col.bottom) {
            yDepth = player.height;
          } else if (!col.top && !col.bottom) {
            yDepth = ent.height;
          } else if (col.top && !col.bottom) {
            yDepth = player.height - ((player.y + player.vel.y + player.height) - (ent.y + ent.height));
          } else if (!col.top && col.bottom) {
            yDepth = player.height - (ent.y - (player.y + player.vel.y));
          }
          collisions = {
            top: false,
            bottom: false,
            left: false,
            right: false
          };
          if (xDepth && yDepth) {
            if ((xDepth < yDepth || !player.vel.y) && player.vel.x < 0 && (col.left || !col.right)) {
              correction = (player.x - (ent.x + ent.width)) / Math.abs(player.vel.x);
              if (correction < xCorrection && solid) {
                xCorrection = correction;
              }
              collisions.right = true;
              if ((_ref1 = player.events) != null) {
                if (typeof _ref1.left_col === "function") {
                  _ref1.left_col(ent);
                }
              }
            } else if ((xDepth < yDepth || !player.vel.y) && player.vel.x > 0 && (col.right || !col.left)) {
              correction = (ent.x - (player.x + player.width)) / Math.abs(player.vel.x);
              if (correction < xCorrection && solid) {
                xCorrection = correction;
              }
              collisions.left = true;
              if ((_ref2 = player.events) != null) {
                if (typeof _ref2.right_col === "function") {
                  _ref2.right_col(ent);
                }
              }
            }
            if ((yDepth < xDepth || !player.vel.x) && player.vel.y < 0 && (col.top || !col.bottom)) {
              correction = (player.y - (ent.y + ent.height)) / Math.abs(player.vel.y);
              if (correction < yCorrection && solid) {
                yCorrection = correction;
              }
              collisions.bottom = true;
              if ((_ref3 = player.events) != null) {
                if (typeof _ref3.top_col === "function") {
                  _ref3.top_col(ent);
                }
              }
            } else if ((yDepth < xDepth || !player.vel.x) && player.vel.y > 0 && (col.bottom || !col.top)) {
              correction = (ent.y - (player.y + player.height)) / Math.abs(player.vel.y);
              if (correction < yCorrection && solid) {
                yCorrection = correction;
              }
              collisions.top = true;
              if ((_ref4 = player.events) != null) {
                if (typeof _ref4.bottom_col === "function") {
                  _ref4.bottom_col(ent);
                }
              }
            }
          }
          if (typeof ent.onHit === "function") {
            ent.onHit(collisions, player);
          }
        }
      }
    }
    player.x += player.vel.x * xCorrection;
    return player.y += player.vel.y * yCorrection;
  };

  Boundary = (function() {
    function Boundary(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.solid = true;
      this.type = 'Boundary';
    }

    Boundary.prototype.draw = function(ctx) {
      return ctx.fillStyle('#1b1b1b').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Boundary;

  })();

  Button = (function() {
    function Button(x, y, onPress, onRelease, once, color) {
      this.x = x;
      this.y = y;
      this.onPress = onPress;
      this.onRelease = onRelease;
      this.once = once;
      this.color = color != null ? color : '#972d32';
      this.solid = true;
      this.width = 4;
      this.height = 2;
      this.type = 'Button';
    }

    Button.prototype.onHit = function(col, ent) {
      this.hadHit = true;
      if (col.top && (this.yCache == null)) {
        this.yCache = this.y;
        this.height = 1;
        this.y = this.yCache + 1;
        ent.y++;
        return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
      } else if ((this.yCache != null) && !this.once) {
        return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
      }
    };

    Button.prototype.update = function() {
      if (!this.hadHit && (this.yCache != null)) {
        this.height = 2;
        this.y = this.yCache;
        delete this.yCache;
        if (typeof this.onRelease === "function") {
          this.onRelease();
        }
      }
      return this.hadHit = false;
    };

    Button.prototype.draw = function(ctx) {
      return ctx.fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Button;

  })();

  Laser = (function() {
    function Laser(x, y, width, height, on, color) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.on = on != null ? on : false;
      this.color = color != null ? color : '#972d32';
      this.solid = false;
      this.type = 'Laser';
    }

    Laser.prototype.isSolidTo = function(ent) {
      return this.on;
    };

    Laser.prototype.onHit = function(col, ent) {
      if (this.on) {
        return typeof ent.die === "function" ? ent.die() : void 0;
      }
    };

    Laser.prototype.draw = function(ctx) {
      var alpha;
      alpha = this.on ? 0.5 : 0.1;
      return ctx.save().globalAlpha(alpha).fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Laser;

  })();

  PlayerSpawn = (function() {
    function PlayerSpawn(x, y, playerType) {
      var _ref;
      this.x = x;
      this.y = y;
      this.player = players[playerType.toLowerCase()];
      this.solid = false;
      this.width = 20;
      this.height = 20;
      if ((_ref = this.player) != null) {
        _ref.spawn = this;
      }
      this.type = 'Spawn';
    }

    PlayerSpawn.prototype.isSolidTo = function(item) {
      return this.type === 'Spawn' && this.player.playerType !== item.playerType;
    };

    PlayerSpawn.prototype.onBuild = function(level) {
      return this.reset();
    };

    PlayerSpawn.prototype.reset = function() {
      var _ref, _ref1, _ref2, _ref3;
      if ((_ref = this.player) != null) {
        _ref.x = this.x + this.width / 2 - ((_ref1 = this.player) != null ? _ref1.width : void 0) / 2;
      }
      return (_ref2 = this.player) != null ? _ref2.y = this.y + this.height / 2 - ((_ref3 = this.player) != null ? _ref3.height : void 0) / 2 : void 0;
    };

    PlayerSpawn.prototype.draw = function(ctx) {
      return ctx.save().globalAlpha(0.5).fillStyle(this.player.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).fillStyle('white').textAlign('left').textBaseline('middle').wrappedText(this.player.lives.toString(), Math.round(this.x) + 7, Math.round(this.y) + this.height / 2, this.width).restore();
    };

    return PlayerSpawn;

  })();

  Item_Spawner = (function() {
    function Item_Spawner(destination, itemTypes, width, height, itemLimit) {
      this.destination = destination;
      this.itemTypes = itemTypes;
      this.width = width;
      this.height = height;
      this.itemLimit = itemLimit != null ? itemLimit : 10;
      this.spawnNewItem = __bind(this.spawnNewItem, this);
      this.setSpawnTimer();
    }

    Item_Spawner.prototype.itemCount = 0;

    Item_Spawner.prototype.itemIdCount = 0;

    Item_Spawner.prototype.setSpawnTimer = function() {
      var maxTime, minTime, time;
      minTime = 30000;
      maxTime = 2000;
      time = Math.round(Math.random() * minTime) + maxTime;
      return setTimeout((function(_this) {
        return function() {
          _this.spawnNewItem();
          return _this.setSpawnTimer();
        };
      })(this), time);
    };

    Item_Spawner.prototype.spawnNewItem = function() {
      var abort, generateLocation, item, itemType, itemTypeIndex, key, maxTries, tries, x, y;
      if (this.itemCount !== this.itemLimit) {
        this.itemCount++;
        this.itemIdCount++;
        key = "Level_Item_" + this.itemIdCount;
        itemTypeIndex = Math.round(Math.random() * (this.itemTypes.length - 1));
        itemType = this.itemTypes[itemTypeIndex];
        item = new items[itemType](this.destination, key, this);
        maxTries = 10;
        tries = 0;
        abort = false;
        x = 0;
        y = 0;
        generateLocation = (function(_this) {
          return function() {
            var col, ent, entSource, i, noCol, oh, ow, ox, oy, _i, _len, _ref;
            x = Math.round(Math.random() * _this.width);
            y = Math.round(Math.random() * _this.height);
            noCol = true;
            _ref = [_this.destination, players];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entSource = _ref[_i];
              for (i in entSource) {
                ent = entSource[i];
                ox = ent.x;
                ow = ent.width;
                oy = ent.x;
                oh = ent.height;
                if (col = hasBoxHit(x, y, item.width, item.height, ent.x, ent.y, ent.width, ent.height)) {
                  noCol = false;
                }
              }
            }
            if (!noCol) {
              if (tries++ !== maxTries - 1) {
                return generateLocation();
              } else {
                return abort = true;
              }
            }
          };
        })(this);
        generateLocation();
        if (!abort) {
          item.x = x;
          item.y = y;
          return this.destination[key] = item;
        }
      }
    };

    return Item_Spawner;

  })();

  items.AddLife = (function() {
    function AddLife(container, key, spawner) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
    }

    AddLife.prototype.type = 'Item';

    AddLife.prototype.x = 0;

    AddLife.prototype.y = 0;

    AddLife.prototype.solid = false;

    AddLife.prototype.width = 5;

    AddLife.prototype.height = 5;

    AddLife.prototype.onHit = function(col, ent) {
      var _ref, _ref1, _ref2;
      if (ent.type === 'Player') {
        ent.lives++;
        if ((_ref = this.spawner) != null) {
          _ref.itemCount--;
        }
        if ((_ref1 = this.container) != null) {
          _ref1[this.key] = void 0;
        }
        return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
      }
    };

    AddLife.prototype.onBuild = function(level) {};

    AddLife.prototype.draw = function(ctx) {
      return ctx.save().fillStyle('#cb71ff').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return AddLife;

  })();

  items.NoWingsEnemy = (function() {
    function NoWingsEnemy(container, key, spawner) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
    }

    NoWingsEnemy.prototype.type = 'Item';

    NoWingsEnemy.prototype.x = 0;

    NoWingsEnemy.prototype.y = 0;

    NoWingsEnemy.prototype.solid = false;

    NoWingsEnemy.prototype.width = 5;

    NoWingsEnemy.prototype.height = 5;

    NoWingsEnemy.prototype.onHit = function(col, ent) {
      var player, _ref, _ref1, _ref2;
      if (ent.type === 'Player') {
        player = ent.other;
        player.addEffect('NoWingsEnemy', function() {
          if (player.cache.noWingsEnemy == null) {
            player.cache.noWingsEnemy = {
              yForce: player.yForce
            };
            player.yForce = 0;
            return removePlayerVelocity(player.playerType, 'up');
          }
        }, function() {
          if (player.cache.noWingsEnemy != null) {
            player.yForce = player.cache.noWingsEnemy.yForce;
            return delete player.cache.noWingsEnemy;
          }
        }, 4000);
        if ((_ref = this.spawner) != null) {
          _ref.itemCount--;
        }
        if ((_ref1 = this.container) != null) {
          _ref1[this.key] = void 0;
        }
        return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
      }
    };

    NoWingsEnemy.prototype.onBuild = function(level) {};

    NoWingsEnemy.prototype.draw = function(ctx) {
      return ctx.save().fillStyle('#8aff58').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return NoWingsEnemy;

  })();

  bombId = 0;

  items.Bomb = (function() {
    function Bomb(container, key, spawner) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
    }

    Bomb.prototype.type = 'Item';

    Bomb.prototype.x = 0;

    Bomb.prototype.y = 0;

    Bomb.prototype.solid = false;

    Bomb.prototype.width = 5;

    Bomb.prototype.height = 5;

    Bomb.prototype.onHit = function(col, ent) {
      var _ref, _ref1, _ref2;
      if (ent.type === 'Player' && (ent.item == null)) {
        ent.item = {
          use: function() {
            var key;
            key = "" + ent.playerType + "_bomb-" + (bombId++);
            return level.midground[key] = {
              type: 'Bomb',
              key: key,
              x: ent.x + ent.width / 2 - 2.5,
              y: ent.y + ent.height / 2 - 2.5,
              width: 6,
              height: 6,
              draw: function(ctx) {
                return ctx.save().fillStyle('#a90007').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).fillStyle(ent.color).fillRect(Math.round(this.x + 1), Math.round(this.y + 1), this.width - 2, this.height - 2).restore();
              },
              onHit: function(c, e) {
                var _ref, _ref1;
                if (e.type === 'Player' && e.playerType !== ent.playerType) {
                  e.die();
                  if ((_ref = level.midground) != null) {
                    _ref[this.key] = void 0;
                  }
                  return (_ref1 = level.midground) != null ? delete _ref1[this.key] : void 0;
                }
              }
            };
          }
        };
        if ((_ref = this.spawner) != null) {
          _ref.itemCount--;
        }
        if ((_ref1 = this.container) != null) {
          _ref1[this.key] = void 0;
        }
        return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
      }
    };

    Bomb.prototype.onBuild = function(level) {};

    Bomb.prototype.draw = function(ctx) {
      return ctx.save().fillStyle('#0b0f16').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Bomb;

  })();

  levels.level_middle = {
    type: 'Map',
    name: 'middle',
    x: 0,
    y: 0,
    width: 300,
    height: 200,
    winner: '',
    render: cq(),
    onEnd: function(type) {
      return console.log('ENDS');
    },
    onBuild: function() {
      var ent, i, ii, source, vars, _ref, _results;
      vars = {};
      this.midground = {
        top: new Boundary(0, 0, 300, 4),
        bottom: new Boundary(0, 196, 300, 4),
        left: new Boundary(0, 0, 4, 200),
        right: new Boundary(296, 0, 4, 200),
        spawn_alien: new PlayerSpawn(50, 20, 'Alien'),
        spawn_human: new PlayerSpawn(230, 20, 'human'),
        row1_left: new Boundary(40, 55, 60, 4),
        row1_right: new Boundary(200, 55, 60, 4),
        row1_barrier_middle: new Boundary(148, 30, 4, 40),
        row1_barrier_right: new Boundary(200, 59, 4, 15),
        row1_barrier_left: new Boundary(96, 59, 4, 15),
        row2_middle: new Boundary(115, 110, 70, 4),
        row2_left: new Boundary(30, 110, 50, 4),
        row2_right: new Boundary(220, 110, 50, 4),
        row3_left: new Boundary(40, 150, 90, 4),
        row3_right: new Boundary(170, 150, 90, 4),
        laser_1_right: new Laser(152, 55, 48, 15, false, '#c1711f'),
        laser_1_left: new Laser(100, 55, 48, 15, false, '#c1711f'),
        laser_1_button: new Button(148, 108, function() {
          level.midground.laser_1_right.on = true;
          return level.midground.laser_1_left.on = true;
        }, function() {
          level.midground.laser_1_right.on = false;
          return level.midground.laser_1_left.on = false;
        }, true, '#c1711f'),
        laser_2_middle: new Laser(148, 4, 4, 26, false),
        laser_2_right_button: new Button(204, 53, function() {
          return vars.laser_2_right_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_right_button = false;
          if (!vars.laser_2_left_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true),
        laser_2_left_button: new Button(92, 53, function() {
          return vars.laser_2_left_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_left_button = false;
          if (!vars.laser_2_right_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true)
      };
      this.spawner = new Item_Spawner(this.midground, ['AddLife', 'Bomb', 'NoWingsEnemy'], this.width, this.height, 5);
      _ref = [players, this.midground, this.foreground];
      _results = [];
      for (i in _ref) {
        source = _ref[i];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (ii in source) {
            ent = source[ii];
            _results1.push(ent != null ? typeof ent.onBuild === "function" ? ent.onBuild(this) : void 0 : void 0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    update: function() {
      this.render.canvas.width = this.width;
      this.render.canvas.height = this.height;
      if (players.human.lives === 0) {
        this.winner = 'Alien';
      }
      if (players.alien.lives === 0) {
        return this.winner = 'human';
      }
    },
    drawBackground: function() {
      return this.render.save().fillStyle('#383838').fillRect(0, 0, this.width, this.height).restore();
    },
    drawMidground: function() {
      var ent, i, _ref;
      this.render.save();
      _ref = this.midground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      return this.render.restore();
    },
    drawForeground: function() {
      var ent, i, _ref;
      this.render.save();
      _ref = this.foreground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      return this.render.restore();
    }
  };

  Player = (function() {
    function Player(playerType, color, controlScheme) {
      this.color = color;
      this.solid = true;
      this.x = 0;
      this.y = 0;
      this.width = 7;
      this.height = 12;
      this.xForce = 1.7;
      this.yForce = 2;
      this.spawn = void 0;
      this.item = void 0;
      this.cache = {};
      this.vel = {
        x: 0,
        y: 0,
        mod: {
          gravity: {
            x: 0,
            y: 0
          }
        }
      };
      ({
        pause: false
      });
      this.playerType = playerType;
      this.effects = {};
      this.onBuild = function(level) {
        this.other = players[playerType === 'alien' ? 'human' : 'alien'];
        return this.lives = 5;
      };
      this.events = {
        top_col: function(ent) {
          if (ent.solid || (typeof ent.isSolidTo === "function" ? ent.isSolidTo(players[playerType]) : void 0)) {
            return players[playerType].vel.mod.up.y = 0;
          }
        },
        bottom_col: function(ent) {
          var _ref;
          if (ent.solid || (typeof ent.isSolidTo === "function" ? ent.isSolidTo(players[playerType]) : void 0)) {
            players[playerType].vel.mod.gravity.y = 0;
            if (!((_ref = players[playerType].keys.w) != null ? _ref.pressed : void 0)) {
              removePlayerVelocity(playerType, 'up');
            }
          }
          if (ent.type === 'Player') {
            return ent.die();
          }
        },
        left_col: function() {},
        right_col: function() {}
      };
      this.keys = {};
      this.keys[controlScheme.up] = {
        press: function() {
          addPlayerVelocity(playerType, 'up', {
            y: -players[playerType].yForce
          });
          return players[playerType].vel.mod.gravity.y = 0;
        }
      };
      this.keys[controlScheme.down] = {
        press: function() {
          return removePlayerVelocity(playerType, 'up');
        }
      };
      this.keys[controlScheme.left] = {
        press: function() {
          return addPlayerVelocity(playerType, 'left', {
            x: -players[playerType].xForce
          });
        },
        release: function() {
          return removePlayerVelocity(playerType, 'left');
        }
      };
      this.keys[controlScheme.right] = {
        press: function() {
          return addPlayerVelocity(playerType, 'right', {
            x: players[playerType].xForce
          });
        },
        release: function() {
          return removePlayerVelocity(playerType, 'right');
        }
      };
      this.keys[controlScheme.item] = {
        press: function() {
          return players[playerType].useItem();
        }
      };
    }

    Player.prototype.type = 'Player';

    Player.prototype.useItem = function() {
      var _ref;
      if ((_ref = this.item) != null) {
        _ref.use();
      }
      return this.item = void 0;
    };

    Player.prototype.removeEffect = function(name) {
      if (this.effects[name] != null) {
        clearTimeout(this.effects[name].timeout);
        this.effects[name].remove();
        this.effects[name] = void 0;
        return delete this.effects[name];
      }
    };

    Player.prototype.addEffect = function(name, add, remove, time) {
      var _ref;
      clearTimeout((_ref = this.effects[name]) != null ? _ref.timeout : void 0);
      remove();
      add();
      return this.effects[name] = {
        remove: remove,
        timeout: setTimeout((function(_this) {
          return function() {
            remove();
            _this.effects[name] = void 0;
            return delete _this.effects[name];
          };
        })(this), time)
      };
    };

    Player.prototype.update = function() {
      var mod, name, _ref;
      if (!this.pause) {
        this.vel.mod.gravity.y += gravity;
        this.vel.x = 0;
        this.vel.y = 0;
        _ref = this.vel.mod;
        for (name in _ref) {
          mod = _ref[name];
          if (mod.x) {
            this.vel.x += mod.x;
          }
          if (mod.y) {
            this.vel.y += mod.y;
          }
        }
      }
      return playerHitsAndVelocity(this);
    };

    Player.prototype.die = function() {
      this.lives--;
      this.vel = {
        x: 0,
        y: 0,
        mod: {
          gravity: {
            x: 0,
            y: 0
          }
        }
      };
      return this.spawn.reset();
    };

    Player.prototype.draw = function(ctx, delta, time) {
      if (level != null) {
        return ctx.save().fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
      }
    };

    return Player;

  })();

  players.human = new Player('human', '#a6a6a6', {
    up: 'up',
    down: 'down',
    left: 'left',
    right: 'right',
    item: 'slash'
  });

  players.alien = new Player('alien', '#58993a', {
    up: 'w',
    down: 's',
    left: 'a',
    right: 'd',
    item: 'g'
  });

  touchMove = false;

  touchTimeout = {};

  this.mouse = mouse = {
    x: 0,
    y: 0,
    down: false,
    up: false
  };

  gameCq = cq().framework({
    onresize: function(width, height) {
      if (mouse.x > width) {
        mouse.x = width;
      }
      if (mouse.y > height) {
        mouse.y = height;
      }
      this.canvas.width = width;
      this.canvas.height = height;
    },
    onmouseup: mouseUpHandler = function(x, y, btn) {
      mouse.down = false;
      mouse.up = true;
      return fireEvent('onmouseup', x, y, btn);
    },
    onmousedown: mouseDownHandler = function(x, y, btn) {
      mouse.down = true;
      return fireEvent('onmousedown', x, y, btn);
    },
    onmousemove: mouseMoveHandler = function(x, y) {
      mouse.x = x;
      return mouse.y = y;
    },
    ontouchstart: function(x, y, touch) {
      if (touch.length === 1) {
        touchDown = true;
        return mouseMoveHandler(x, y);
      }
    },
    ontouchmove: function(x, y, touch) {
      touchMove = true;
      return mouseMoveHandler(x, y);
    },
    ontouchend: function(x, y, touch) {
      touchDown = false;
      if (!touchMove) {
        mouseDownHandler(x, y);
        clearTimeout(touchTimeout);
        touchTimeout = setTimeout(function() {
          return mouseUpHandler(x, y);
        }, 100);
      }
      return touchMove = false;
    },
    onkeydown: function(key) {
      var name, player, _base, _results;
      _results = [];
      for (name in players) {
        player = players[name];
        if ((player.keys[key] != null) && !player.keys[key].pressed) {
          player.keys[key].pressed = true;
          _results.push(typeof (_base = player.keys[key]).press === "function" ? _base.press() : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    onkeyup: function(key) {
      var name, player, _base, _results;
      _results = [];
      for (name in players) {
        player = players[name];
        if ((player.keys[key] != null) && player.keys[key].pressed) {
          player.keys[key].pressed = false;
          _results.push(typeof (_base = player.keys[key]).release === "function" ? _base.release() : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    onrender: function(delta, time) {
      var entity, i, name, player;
      this.clear('#202424');
      this.context.mozImageSmoothingEnabled = this.context.webkitImageSmoothingEnabled = this.context.msImageSmoothingEnabled = this.context.imageSmoothingEnabled = false;
      level.render.context.mozImageSmoothingEnabled = level.render.context.webkitImageSmoothingEnabled = level.render.context.msImageSmoothingEnabled = level.render.context.imageSmoothingEnabled = false;
      resizeFactor = Math.min(gameCanvas.width / level.width, gameCanvas.height / (level.height + 20));
      if (level != null) {
        if (typeof level.update === "function") {
          level.update();
        }
      }
      if (!level.winner) {
        if (level != null) {
          if (typeof level.drawBackground === "function") {
            level.drawBackground();
          }
        }
        for (name in players) {
          player = players[name];
          if (typeof player.update === "function") {
            player.update();
          }
          if (typeof player.draw === "function") {
            player.draw(level.render, delta, time);
          }
        }
        if (level != null) {
          if (typeof level.drawMidground === "function") {
            level.drawMidground();
          }
        }
        if (level != null) {
          if (typeof level.drawForeground === "function") {
            level.drawForeground();
          }
        }
        for (i in HUD) {
          entity = HUD[i];
          if (typeof entity.update === "function") {
            entity.update();
          }
          if (typeof entity.draw === "function") {
            entity.draw(level.render, delta, time, parseInt(i));
          }
        }
      } else {
        level.render.save().textAlign('center').textBaseline('middle').fillStyle(players[level.winner.toLowerCase()].color).wrappedText("The " + level.winner + " won!", level.width / 2, level.height / 2, level.width).restore();
      }
      this.save().translate(gameCanvas.width / 2 - (level.width * resizeFactor) / 2, gameCanvas.height / 2 - (level.height * resizeFactor) / 2).drawImage(level.render.canvas, 0, 0, level.width * resizeFactor, level.height * resizeFactor).restore();
      mouse.up = false;
    }
  });

  gameCanvas = gameCq.canvas;

  onEvent('assetsLoaded', function() {
    console.log('loaded');
    loadLevel('middle');
    gameCanvas.width = root.innerWidth;
    gameCanvas.height = root.innerHeight;
    gameCq.appendTo('body');
    mouse.x = gameCanvas.width / 2;
    mouse.y = gameCanvas.height / 2;
    mouse.up = false;
    return mouse.down = false;
  });

}).call(this);
