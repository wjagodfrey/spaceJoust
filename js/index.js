// Generated by CoffeeScript 1.7.1
(function() {
  var Item, Item_Spawner, Player, addPlayerVelocity, applyPhysics, bombBackgroundColor, bombBehaviourIndicatorColor, bombId, entity, events, fireEvent, frameTimeouts, gameCanvas, gameCq, gravity, hasBoxHit, hasMouseHit, item, level, levels, loadLevel, loaded, modifyPlayerScore, mouse, mouseDownHandler, mouseMoveHandler, mouseUpHandler, onEvent, players, removePlayerVelocity, resizeFactor, root, setFrameTimeout, touchDown, touchMove, touchTimeout, updateFrameTimeouts,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = this;

  loaded = false;

  touchDown = false;

  this.levels = levels = {};

  this.players = players = {};

  this.item = item = {};

  this.entity = entity = {};

  this.level = level = void 0;

  resizeFactor = 2;

  gravity = 0.1;

  'use strict';

  events = {};

  onEvent = function(eventName, eventHandler) {
    if (events[eventName] == null) {
      events[eventName] = [];
    }
    events[eventName].push(eventHandler);
    return function() {
      return events[eventName].splice(events[eventName].indexOf(eventHandler), 1);
    };
  };

  fireEvent = function() {
    var args, eventHandler, eventName, _i, _len, _ref, _ref1, _results;
    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((_ref = events[eventName]) != null ? _ref.length : void 0) {
      _ref1 = events[eventName];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        eventHandler = _ref1[_i];
        _results.push(eventHandler.apply(null, args));
      }
      return _results;
    }
  };

  this.frameCount = 0;

  this.frameTimeouts = frameTimeouts = {};

  setFrameTimeout = function(callback, time) {
    var removed, targetFrame;
    if (time == null) {
      time = 0;
    }
    targetFrame = root.frameCount + Math.ceil(time * 0.06);
    if (targetFrame <= (root.frameCount + 1)) {
      return setTimeout(callback);
    } else {
      if (frameTimeouts[targetFrame] == null) {
        frameTimeouts[targetFrame] = [];
      }
      frameTimeouts[targetFrame].push(callback);
      removed = false;
      return (function(_this) {
        return function() {
          if (!removed) {
            if (frameTimeouts[targetFrame]) {
              frameTimeouts[targetFrame].splice(frameTimeouts[targetFrame].indexOf(callback), 1);
            }
            return removed = true;
          }
        };
      })(this);
    }
  };

  updateFrameTimeouts = function() {
    var callback, targetFrame, _i, _len, _ref;
    targetFrame = root.frameCount++;
    if (frameTimeouts[targetFrame]) {
      _ref = frameTimeouts[targetFrame];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback();
      }
      frameTimeouts[targetFrame] = void 0;
      return delete frameTimeouts[targetFrame];
    }
  };

  hasMouseHit = function(x, y, width, height) {
    var col;
    col = {
      x: x + width / 2 >= mouse.x && x - width / 2 <= mouse.x,
      y: y + height / 2 >= mouse.y && y - height / 2 <= mouse.y
    };
    if (col.x && col.y) {
      return true;
    } else {
      return false;
    }
  };

  hasBoxHit = function(_ax, _ay, _awidth, _aheight, _bx, _by, _bwidth, _bheight) {
    var aX, aXX, aY, aYY, bX, bXX, bY, bYY, col;
    aX = _ax;
    aXX = _ax + _awidth;
    aY = _ay;
    aYY = _ay + _aheight;
    bX = _bx;
    bXX = _bx + _bwidth;
    bY = _by;
    bYY = _by + _bheight;
    col = {
      x: (aX >= bX && aX <= bXX || aXX >= bX && aXX <= bXX) || (bX >= aX && bX <= aXX || bXX >= aX && bXX <= aXX),
      y: (aY >= bY && aY <= bYY || aYY >= bY && aYY <= bYY) || (bY >= aY && bY <= aYY || bYY >= aY && bYY <= aYY)
    };
    if (col.x && col.y) {
      return {
        left: aX >= bX && aX <= bXX,
        right: aXX >= bX && aXX <= bXX,
        top: aY >= bY && aY <= bYY,
        bottom: aYY >= bY && aYY <= bYY
      };
    } else {
      return false;
    }
  };

  loadLevel = (function(_this) {
    return function(name) {
      root.level = level = levels["level_" + name] || {};
      return typeof level.onBuild === "function" ? level.onBuild() : void 0;
    };
  })(this);

  modifyPlayerScore = function(player, score) {
    if (level != null) {
      level.addFloatingScore(players[player].x, players[player].y, score);
    }
    return players[player].score += score;
  };

  addPlayerVelocity = function(player, name, vector) {
    players[player].vel.mod[name] = {};
    if (vector.x) {
      players[player].vel.mod[name].x = vector.x;
    }
    if (vector.y) {
      return players[player].vel.mod[name].y = vector.y;
    }
  };

  removePlayerVelocity = function(player, name) {
    return delete players[player].vel.mod[name];
  };

  applyPhysics = function(ent1) {
    var col, correction, ent1Collisions, ent1Solid, ent2, ent2Collisions, ent2Solid, entSource, i, oh, ow, ox, oy, runCorrection, xCorrection, xDepth, yCorrection, yDepth, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    xCorrection = 1;
    yCorrection = 1;
    _ref = [level != null ? level.midground : void 0, players];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entSource = _ref[_i];
      for (i in entSource) {
        ent2 = entSource[i];
        if (ent1 !== ent2) {
          ox = ent2.x;
          ow = ent2.width;
          oy = ent2.x;
          oh = ent2.height;
          if (col = hasBoxHit(ent1.x + ent1.vel.x, ent1.y + ent1.vel.y, ent1.width, ent1.height, ent2.x, ent2.y, ent2.width, ent2.height)) {
            ent1Solid = typeof ent1.isSolidTo === "function" ? ent1.isSolidTo(ent2) : void 0;
            ent2Solid = typeof ent2.isSolidTo === "function" ? ent2.isSolidTo(ent1) : void 0;
            ent1Collisions = {
              top: false,
              bottom: false,
              left: false,
              right: false
            };
            ent2Collisions = {
              top: false,
              bottom: false,
              left: false,
              right: false
            };
            if (ent1Solid && ent2Solid) {
              xDepth = 0;
              yDepth = 0;
              if (col.left && col.right) {
                xDepth = ent1.width;
              } else if (!col.left && !col.right) {
                xDepth = ent2.width;
              } else if (col.left && !col.right) {
                xDepth = ent1.width - ((ent1.x + ent1.vel.x + ent1.width) - (ent2.x + ent2.width));
              } else if (!col.left && col.right) {
                xDepth = ent1.width - (ent2.x - (ent1.x + ent1.vel.x));
              }
              if (col.top && col.bottom) {
                yDepth = ent1.height;
              } else if (!col.top && !col.bottom) {
                yDepth = ent2.height;
              } else if (col.top && !col.bottom) {
                yDepth = ent1.height - ((ent1.y + ent1.vel.y + ent1.height) - (ent2.y + ent2.height));
              } else if (!col.top && col.bottom) {
                yDepth = ent1.height - (ent2.y - (ent1.y + ent1.vel.y));
              }
              runCorrection = !(typeof ent1.noCorrectionWith === "function" ? ent1.noCorrectionWith(ent2) : void 0) && !(typeof ent2.noCorrectionWith === "function" ? ent2.noCorrectionWith(ent1) : void 0);
              if (xDepth && yDepth) {
                if ((xDepth < yDepth || !ent1.vel.y) && ent1.vel.x < 0 && (col.left || !col.right)) {
                  if (runCorrection) {
                    correction = (ent1.x - (ent2.x + ent2.width)) / Math.abs(ent1.vel.x);
                    if (correction < xCorrection) {
                      xCorrection = correction;
                    }
                  }
                  ent1Collisions.left = true;
                  ent2Collisions.right = true;
                  if ((_ref1 = ent1.events) != null) {
                    if (typeof _ref1.left_col === "function") {
                      _ref1.left_col(ent2);
                    }
                  }
                } else if ((xDepth < yDepth || !ent1.vel.y) && ent1.vel.x > 0 && (col.right || !col.left)) {
                  if (runCorrection) {
                    correction = (ent2.x - (ent1.x + ent1.width)) / Math.abs(ent1.vel.x);
                    if (correction < xCorrection) {
                      xCorrection = correction;
                    }
                  }
                  ent1Collisions.right = true;
                  ent2Collisions.left = true;
                  if ((_ref2 = ent1.events) != null) {
                    if (typeof _ref2.right_col === "function") {
                      _ref2.right_col(ent2);
                    }
                  }
                }
                if ((yDepth < xDepth || !ent1.vel.x) && ent1.vel.y < 0 && (col.top || !col.bottom)) {
                  if (runCorrection) {
                    correction = (ent1.y - (ent2.y + ent2.height)) / Math.abs(ent1.vel.y);
                    if (correction < yCorrection) {
                      yCorrection = correction;
                    }
                  }
                  ent1Collisions.top = true;
                  ent2Collisions.bottom = true;
                  if ((_ref3 = ent1.events) != null) {
                    if (typeof _ref3.top_col === "function") {
                      _ref3.top_col(ent2);
                    }
                  }
                } else if ((yDepth < xDepth || !ent1.vel.x) && ent1.vel.y > 0 && (col.bottom || !col.top)) {
                  if (runCorrection) {
                    correction = (ent2.y - (ent1.y + ent1.height)) / Math.abs(ent1.vel.y);
                    if (correction < yCorrection) {
                      yCorrection = correction;
                    }
                  }
                  ent1Collisions.bottom = true;
                  ent2Collisions.top = true;
                  if ((_ref4 = ent1.events) != null) {
                    if (typeof _ref4.bottom_col === "function") {
                      _ref4.bottom_col(ent2);
                    }
                  }
                }
              }
            }
            if (typeof ent2.onHit === "function") {
              ent2.onHit(ent2Collisions, ent1, ent1Solid);
            }
            if (typeof ent1.onHit === "function") {
              ent1.onHit(ent1Collisions, ent2, ent2Solid);
            }
          }
        }
      }
    }
    ent1.x += ent1.vel.x * xCorrection;
    return ent1.y += ent1.vel.y * yCorrection;
  };

  setFrameTimeout(function() {
    return fireEvent('assetsLoaded');
  });

  entity.Score = (function() {
    function Score() {}

    Score.prototype.update = function() {
      var score, _i, _len, _ref, _results;
      _ref = level.floatingScores;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        score = _ref[_i];
        _results.push(score.update());
      }
      return _results;
    };

    Score.prototype.draw = function(ctx) {
      var score, _i, _len, _ref;
      _ref = level.floatingScores;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        score = _ref[_i];
        score.draw(ctx);
      }
      return ctx.save().globalAlpha(0.7).font('Helvetica').textBaseline('top').textAlign('left').fillStyle(players.alien.color).fillText(players.alien.score, 3, 2).textAlign('right').fillStyle(players.human.color).fillText(players.human.score, level.width - 3, 2).restore();
    };

    return Score;

  })();

  entity.Boundary = (function() {
    function Boundary(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.type = 'Boundary';
    }

    Boundary.prototype.isSolidTo = function() {
      return true;
    };

    Boundary.prototype.draw = function(ctx) {
      return ctx.fillStyle('#1b1b1b').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Boundary;

  })();

  entity.Button = (function() {
    function Button(x, y, onPress, onRelease, once, color) {
      this.x = x;
      this.y = y;
      this.onPress = onPress;
      this.onRelease = onRelease;
      this.once = once;
      this.color = color != null ? color : '#972d32';
      this.width = 4;
      this.height = 2;
      this.type = 'Button';
      this.pressed = false;
    }

    Button.prototype.isSolidTo = function() {
      return true;
    };

    Button.prototype.onHit = function(col, ent) {
      var _ref;
      if ((_ref = ent.type) === 'Player' || _ref === 'Bomb') {
        this.hadHit = true;
        if ((col.top || col.right || col.left) && !this.pressed) {
          this.pressed = true;
          this.yCache = this.y;
          this.height = 1;
          this.y = this.yCache + 1;
          ent.y = this.y - ent.height;
          return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
        } else if ((this.yCache != null) && !this.once) {
          return typeof this.onPress === "function" ? this.onPress(col, ent) : void 0;
        }
      }
    };

    Button.prototype.update = function() {
      if (!this.hadHit && this.pressed) {
        this.pressed = false;
        this.height = 2;
        this.y = this.yCache;
        delete this.yCache;
        if (typeof this.onRelease === "function") {
          this.onRelease();
        }
      }
      return this.hadHit = false;
    };

    Button.prototype.draw = function(ctx) {
      return ctx.fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
    };

    return Button;

  })();

  entity.Laser = (function() {
    function Laser(x, y, width, height, on, color) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.on = on != null ? on : false;
      this.color = color != null ? color : '#972d32';
      this.type = 'Laser';
    }

    Laser.prototype.isSolidTo = function(ent) {
      return this.on;
    };

    Laser.prototype.onHit = function(col, ent) {
      if (this.on && ent.type === 'Player') {
        return ent.die((function(_this) {
          return function() {
            return modifyPlayerScore(ent.playerType, -5);
          };
        })(this));
      }
    };

    Laser.prototype.draw = function(ctx) {
      var alpha;
      alpha = this.on ? 1 : 0.1;
      return ctx.save().globalAlpha(alpha).fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Laser;

  })();

  entity.PlayerSpawn = (function() {
    function PlayerSpawn(x, y, playerType) {
      var _ref;
      this.x = x;
      this.y = y;
      this.player = players[playerType.toLowerCase()];
      this.width = 20;
      this.height = 35;
      if ((_ref = this.player) != null) {
        _ref.spawn = this;
      }
      this.type = 'Spawn';
    }

    PlayerSpawn.prototype.lockoutCount = 30;

    PlayerSpawn.prototype.isSolidTo = function(item) {
      return this.type === 'Spawn' && (this.player.playerType !== item.playerType || this.closed);
    };

    PlayerSpawn.prototype.onBuild = function(level) {
      return this.reset();
    };

    PlayerSpawn.prototype.reset = function() {
      var _ref, _ref1, _ref2, _ref3;
      this.closed = false;
      this.hitCount = 0;
      this.updateCount = 0;
      if ((_ref = this.player) != null) {
        _ref.x = this.x + this.width / 2 - ((_ref1 = this.player) != null ? _ref1.width : void 0) / 2;
      }
      return (_ref2 = this.player) != null ? _ref2.y = this.y + this.height / 2 - ((_ref3 = this.player) != null ? _ref3.height : void 0) / 2 : void 0;
    };

    PlayerSpawn.prototype.update = function() {
      if (!this.closed) {
        this.updateCount++;
        if (this.updateCount - this.hitCount > this.lockoutCount) {
          return this.closed = true;
        }
      }
    };

    PlayerSpawn.prototype.onHit = function(col, ent) {
      if (ent.playerType === this.player.playerType && !this.closed) {
        if (this.hitCount !== this.updateCount) {
          this.hitCount = 0;
          this.updateCount = 0;
        }
        return this.hitCount++;
      }
    };

    PlayerSpawn.prototype.draw = function(ctx) {
      var barHeight, lifeCount, _results;
      ctx.save().globalAlpha(this.closed ? 0.8 : 0.2).fillStyle(this.player.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
      barHeight = this.height / this.player.maxLives - 2;
      lifeCount = 0;
      _results = [];
      while (lifeCount++ < this.player.lives) {
        _results.push(ctx.save().globalAlpha(0.2).fillStyle('white').fillRect(Math.round(this.x), Math.round((this.y + this.height) + 1 - ((barHeight + 2) * lifeCount)), this.width, barHeight).restore());
      }
      return _results;
    };

    return PlayerSpawn;

  })();

  bombBehaviourIndicatorColor = '#939393';

  bombBackgroundColor = '#222222';

  entity.Bomb = (function() {
    function Bomb(ent, key, xBounce, yBounce) {
      this.ent = ent;
      this.key = key;
      this.xBounce = xBounce;
      this.yBounce = yBounce;
      this.type = 'Bomb';
      this.x = this.ent.x + this.ent.width / 2 - 3;
      this.y = this.ent.y + this.ent.height / 2 - 3;
      this.width = 6;
      this.height = 6;
      this.force = 1.3;
      this.direction = {
        x: Math.round(Math.random()) || -1,
        y: Math.round(Math.random()) || -1
      };
      this.vel = {
        x: 0,
        y: 0
      };
      this.explode = {
        exploding: false,
        size: 0,
        sizeSpeed: 8,
        sizeLimit: 40,
        color: '#ffe2d0'
      };
      this.armed = false;
      this.hitCount = 0;
      this.updateCount = 0;
      this.lockoutCount = this.yBounce || this.xBounce ? 20 : 5;
    }

    Bomb.prototype.noCorrectionWith = function(ent) {
      var _ref;
      return (_ref = ent.type) === 'SuddenDeath' || _ref === 'Laser';
    };

    Bomb.prototype.isSolidTo = function(ent) {
      return this.armed;
    };

    Bomb.prototype.boom = function() {
      level.shake.start();
      return this.explode.exploding = true;
    };

    Bomb.prototype.draw = function(ctx) {
      if (!this.explode.exploding) {
        ctx.save().fillStyle(bombBackgroundColor).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
        if (this.xBounce) {
          ctx.save().fillStyle(this.armed ? this.ent.color : bombBehaviourIndicatorColor).fillRect(Math.round(this.x), Math.round(this.y + 2), this.width, this.height - 4).restore();
        }
        if (this.yBounce) {
          ctx.save().fillStyle(this.armed ? this.ent.color : bombBehaviourIndicatorColor).fillRect(Math.round(this.x + 2), Math.round(this.y), this.width - 4, this.height).restore();
        }
        return ctx.save().fillStyle(this.armed ? this.ent.color : bombBehaviourIndicatorColor).fillRect(Math.round(this.x + 1), Math.round(this.y + 1), this.width - 2, this.height - 2).restore();
      } else {
        return ctx.save().fillStyle(this.explode.color).fillRect(Math.round(this.x - this.explode.size / 2), Math.round(this.y - this.explode.size / 2), this.explode.size, this.explode.size).restore();
      }
    };

    Bomb.prototype.update = function() {
      var ent, _ref, _ref1;
      if (!this.armed) {
        this.updateCount++;
        if (this.updateCount - this.hitCount > this.lockoutCount) {
          return this.armed = true;
        }
      } else {
        if (this.explode.exploding) {
          if (this.explode.size < this.explode.sizeLimit) {
            this.explode.size += this.explode.sizeSpeed;
            ent = this.ent;
            applyPhysics({
              isSolidTo: function() {
                return true;
              },
              type: 'Explosion',
              x: this.x - this.explode.size / 2,
              y: this.y - this.explode.size / 2,
              width: this.explode.size,
              height: this.explode.size,
              vel: {
                x: 0,
                y: 0
              },
              onHit: function(c, e, solid) {
                if (e.type === 'Player') {
                  return e.die((function(_this) {
                    return function() {
                      if (e.playerType === ent.playerType) {
                        return modifyPlayerScore(e.playerType, -5);
                      } else {
                        return modifyPlayerScore(ent.playerType, +200000);
                      }
                    };
                  })(this));
                }
              }
            });
          } else {
            if ((_ref = level.midground) != null) {
              _ref[this.key] = void 0;
            }
            if ((_ref1 = level.midground) != null) {
              delete _ref1[this.key];
            }
          }
        } else if (this.xBounce || this.yBounce) {
          if (this.yBounce) {
            this.vel.y = this.force * this.direction.y;
          }
          if (this.xBounce) {
            this.vel.x = this.force * this.direction.x;
          }
        }
        return applyPhysics(this);
      }
    };

    Bomb.prototype.onHit = function(c, e, solid) {
      var _ref;
      if (e.type === 'Player' && e.playerType === this.ent.playerType && !this.armed) {
        if (this.hitCount !== this.updateCount) {
          this.hitCount = 0;
          this.updateCount = 0;
        }
        return this.hitCount++;
      } else if (((_ref = e.type) === 'Player' || _ref === 'Laser' || _ref === 'Explosion' || _ref === 'Bomb') && this.armed && solid) {
        return this.boom();
      } else if ((this.xBounce || this.yBounce) && solid) {
        if (this.yBounce) {
          if (c.bottom) {
            this.direction.y = -1;
          } else if (c.top) {
            this.direction.y = 1;
          }
        }
        if (this.xBounce) {
          if (c.right) {
            return this.direction.x = -1;
          } else if (c.left) {
            return this.direction.x = 1;
          }
        }
      }
    };

    return Bomb;

  })();

  entity.SuddenDeath = (function() {
    function SuddenDeath(level, height) {
      var randomBloop;
      this.level = level;
      this.height = height != null ? height : 0;
      this.type = 'SuddenDeath';
      this.x = 0;
      this.y = this.level.height - this.height;
      this.width = this.level.width;
      this.grow = false;
      this.timeout = setFrameTimeout((function(_this) {
        return function() {
          return _this.startGrowth();
        };
      })(this), 10000);
      randomBloop = (function(_this) {
        return function() {
          return setFrameTimeout(function() {
            var width;
            _this.bloops.push({
              width: width = Math.round(6 * Math.random()) + 7,
              maxHeight: height = Math.round(8 * Math.random()) + 8,
              x: Math.round((level.width + width) * Math.random()) - width / 2,
              growthDir: 1,
              height: 1,
              speed: ((height / 12) * 0.8) * (Math.round(Math.random() + 1.5))
            });
            return randomBloop();
          }, Math.round(800 * Math.random()) + 2000);
        };
      })(this);
      randomBloop();
    }

    SuddenDeath.prototype.vel = {
      x: 0,
      y: 0
    };

    SuddenDeath.prototype.speed = 0.01;

    SuddenDeath.prototype.bloops = [];

    SuddenDeath.prototype.isSolidTo = function(ent) {
      return true;
    };

    SuddenDeath.prototype.startGrowth = function() {
      return this.grow = true;
    };

    SuddenDeath.prototype.stopGrowth = function() {
      if (typeof this.timeout === "function") {
        this.timeout();
      }
      this.grow = false;
      this.height -= this.speed + 3;
      this.y = level.height - this.height;
      return applyPhysics(this);
    };

    SuddenDeath.prototype.update = function() {
      var bloop, easing, heightDelta, i, widthDelta, _ref, _results;
      if (this.grow) {
        this.height += this.speed;
      }
      this.y = level.height - this.height + 1;
      applyPhysics(this);
      if (this.height >= level.height / 2) {
        this.stopGrowth();
      }
      _ref = this.bloops;
      _results = [];
      for (i in _ref) {
        bloop = _ref[i];
        if (bloop.height < 1) {
          _results.push(this.bloops.splice(i, 1));
        } else {
          easing = 1 - bloop.height / bloop.maxHeight;
          if (bloop.growthDir > 0) {
            widthDelta = (bloop.width / 10) * (bloop.height / bloop.maxHeight);
            bloop.width -= widthDelta;
            bloop.x += widthDelta / 2;
          }
          heightDelta = bloop.speed * easing * bloop.growthDir;
          bloop.height += heightDelta;
          if (bloop.height >= bloop.maxHeight - 1) {
            _results.push(bloop.growthDir = -1);
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    SuddenDeath.prototype.onHit = function(col, ent) {
      var height, _ref;
      if ((_ref = ent.type) === 'Player' || _ref === 'Bomb' || _ref === 'Item') {
        this.bloops.push({
          x: ent.x,
          width: ent.width,
          maxHeight: height = ent.height * 1.5,
          growthDir: 1,
          height: 1,
          speed: ((height / 12) * 0.8) * (Math.round(Math.random() + 1.5))
        });
        if (ent.type === 'Player') {
          ent.die((function(_this) {
            return function() {
              return modifyPlayerScore(ent.playerType, -10);
            };
          })(this));
        }
        if (ent.type === 'Bomb') {
          if (typeof ent.boom === "function") {
            ent.boom();
          }
        }
        if (ent.type === 'Item') {
          return typeof ent.destroy === "function" ? ent.destroy() : void 0;
        }
      } else if (ent.type === 'Spawn') {
        return this.stopGrowth();
      }
    };

    SuddenDeath.prototype.draw = function(ctx) {
      var bloop, _i, _len, _ref;
      ctx.save().fillStyle('orange').fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
      _ref = this.bloops;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bloop = _ref[_i];
        ctx.fillRect(Math.round(bloop.x), Math.round(this.y - bloop.height), Math.round(bloop.width), Math.round(bloop.height + 1));
      }
      return ctx.restore();
    };

    return SuddenDeath;

  })();

  Item = (function() {
    function Item() {}

    Item.prototype.type = 'Item';

    Item.prototype.color = 'white';

    Item.prototype.x = 0;

    Item.prototype.y = 0;

    Item.prototype.width = 5;

    Item.prototype.height = 5;

    Item.prototype.onHit = function(col, ent) {
      return this.destroy();
    };

    Item.prototype.destroy = function() {
      var _ref, _ref1, _ref2;
      if ((_ref = this.spawner) != null) {
        _ref.itemCount--;
      }
      if ((_ref1 = this.container) != null) {
        _ref1[this.key] = void 0;
      }
      return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
    };

    Item.prototype.draw = function(ctx) {
      return ctx.save().fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
    };

    return Item;

  })();

  Item_Spawner = (function() {
    function Item_Spawner(destination, itemTypes, width, height, itemLimit) {
      this.destination = destination;
      this.itemTypes = itemTypes;
      this.width = width;
      this.height = height;
      this.itemLimit = itemLimit != null ? itemLimit : 10;
      this.spawnNewItem = __bind(this.spawnNewItem, this);
      this.setSpawnTimer();
    }

    Item_Spawner.prototype.itemCount = 0;

    Item_Spawner.prototype.itemIdCount = 0;

    Item_Spawner.prototype.setSpawnTimer = function() {
      var devTime, maxTime, minTime, time;
      minTime = 100;
      maxTime = 1000;
      devTime = 0;
      time = devTime != null ? devTime : Math.round(Math.random() * minTime) + maxTime;
      return setFrameTimeout((function(_this) {
        return function() {
          _this.spawnNewItem();
          return _this.setSpawnTimer();
        };
      })(this), time);
    };

    Item_Spawner.prototype.spawnNewItem = function() {
      var abort, args, generateLocation, i, itemType, itemTypeIndex, key, maxTries, newItem, tries, x, y;
      if (this.itemCount !== this.itemLimit) {
        this.itemCount++;
        this.itemIdCount++;
        key = "Level_Item_" + this.itemIdCount;
        itemTypeIndex = Math.round(Math.random() * (this.itemTypes.length - 1));
        itemType = this.itemTypes[itemTypeIndex];
        args = [];
        if (itemType instanceof Array) {
          i = itemType[0];
          args = itemType.slice(1);
          itemType = i;
        }
        newItem = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(item[itemType], [this.destination, key, this].concat(__slice.call(args)), function(){});
        maxTries = 10;
        tries = 0;
        abort = false;
        x = 0;
        y = 0;
        generateLocation = (function(_this) {
          return function() {
            var col, ent, entSource, noCol, oh, ow, ox, oy, _i, _len, _ref;
            x = Math.round(Math.random() * _this.width);
            y = Math.round(Math.random() * _this.height);
            noCol = true;
            _ref = [_this.destination, players];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entSource = _ref[_i];
              for (i in entSource) {
                ent = entSource[i];
                ox = ent.x;
                ow = ent.width;
                oy = ent.x;
                oh = ent.height;
                if (col = hasBoxHit(x, y, newItem.width, newItem.height, ent.x, ent.y, ent.width, ent.height)) {
                  noCol = false;
                }
              }
            }
            if (!noCol) {
              if (tries++ !== maxTries - 1) {
                return generateLocation();
              } else {
                return abort = true;
              }
            }
          };
        })(this);
        generateLocation();
        if (!abort) {
          newItem.x = x;
          newItem.y = y;
          return this.destination[key] = newItem;
        }
      }
    };

    return Item_Spawner;

  })();

  item.AddLife = (function(_super) {
    __extends(AddLife, _super);

    function AddLife(container, key, spawner) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
    }

    AddLife.prototype.color = '#cb71ff';

    AddLife.prototype.onHit = function(col, ent) {
      if (ent.type === 'Player') {
        ent.lives++;
        if (ent.lives > ent.maxLives) {
          ent.lives = ent.maxLives;
        }
        return this.destroy();
      }
    };

    return AddLife;

  })(Item);

  item.NoWingsEnemy = (function(_super) {
    __extends(NoWingsEnemy, _super);

    function NoWingsEnemy(container, key, spawner) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
    }

    NoWingsEnemy.prototype.color = '#8aff58';

    NoWingsEnemy.prototype.onHit = function(col, ent) {
      var player, _ref, _ref1, _ref2;
      if (ent.type === 'Player') {
        player = ent.other;
        player.addEffect('NoWingsEnemy', function() {
          if (player.cache.noWingsEnemy == null) {
            player.cache.noWingsEnemy = {
              yForce: player.yForce
            };
            player.yForce = 0;
            return removePlayerVelocity(player.playerType, 'up');
          }
        }, function() {
          if (player.cache.noWingsEnemy != null) {
            player.yForce = player.cache.noWingsEnemy.yForce;
            return delete player.cache.noWingsEnemy;
          }
        }, 4000);
        if ((_ref = this.spawner) != null) {
          _ref.itemCount--;
        }
        if ((_ref1 = this.container) != null) {
          _ref1[this.key] = void 0;
        }
        return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
      }
    };

    return NoWingsEnemy;

  })(Item);

  bombId = 0;

  item.Bomb = (function(_super) {
    __extends(Bomb, _super);

    function Bomb(container, key, spawner, xBounce, yBounce) {
      this.container = container;
      this.key = key;
      this.spawner = spawner;
      this.xBounce = xBounce;
      this.yBounce = yBounce;
    }

    Bomb.prototype.color = bombBackgroundColor;

    Bomb.prototype.onHit = function(col, ent) {
      var _ref, _ref1, _ref2;
      if (ent.type === 'Player' && (ent.item == null)) {
        ent.item = {
          use: (function(_this) {
            return function() {
              var key;
              if (!hasBoxHit(ent.x + ent.width / 2 - 3, ent.y + ent.height / 2 - 3, 6, 6, ent.spawn.x, ent.spawn.y, ent.spawn.width, ent.spawn.height)) {
                ent.item = void 0;
                key = "" + ent.playerType + "_bomb-" + (bombId++);
                return level.midground[key] = new entity.Bomb(ent, key, _this.xBounce, _this.yBounce);
              }
            };
          })(this),
          draw: (function(_this) {
            return function(ctx) {
              var height, width;
              width = 5;
              height = 5;
              ctx.save().fillStyle(_this.color).fillRect(Math.round(ent.x + (ent.width - width) / 2), Math.round(ent.y + (ent.height - height) / 2), width, height).restore();
              if (_this.xBounce) {
                ctx.save().fillStyle(bombBehaviourIndicatorColor).fillRect(Math.round(ent.x + (ent.width - width) / 2), Math.round(ent.y + (ent.height - height) / 2 + 2), width, height - 4).restore();
              }
              if (_this.yBounce) {
                return ctx.save().fillStyle(bombBehaviourIndicatorColor).fillRect(Math.round(ent.x + (ent.width - width) / 2 + 2), Math.round(ent.y + (ent.height - height) / 2), width - 4, height).restore();
              }
            };
          })(this)
        };
        if ((_ref = this.spawner) != null) {
          _ref.itemCount--;
        }
        if ((_ref1 = this.container) != null) {
          _ref1[this.key] = void 0;
        }
        return (_ref2 = this.container) != null ? delete _ref2[this.key] : void 0;
      }
    };

    Bomb.prototype.draw = function(ctx) {
      Bomb.__super__.draw.call(this, ctx);
      if (this.xBounce) {
        ctx.save().fillStyle(bombBehaviourIndicatorColor).fillRect(Math.round(this.x), Math.round(this.y + 2), this.width, this.height - 4).restore();
      }
      if (this.yBounce) {
        return ctx.save().fillStyle(bombBehaviourIndicatorColor).fillRect(Math.round(this.x + 2), Math.round(this.y), this.width - 4, this.height).restore();
      }
    };

    return Bomb;

  })(Item);

  levels.level_middle = {
    type: 'Map',
    name: 'middle',
    x: 0,
    y: 0,
    width: 300,
    height: 200,
    offsetX: 0,
    offsetY: 0,
    winner: '',
    render: cq(),
    onEnd: function(type) {
      return console.log('ENDS');
    },
    onBuild: function() {
      var ent, i, ii, source, vars, _ref, _results;
      vars = {};
      this.foreground = {
        score: new entity.Score
      };
      this.midground = {
        top: new entity.Boundary(0, 0, 300, 4),
        bottom: new entity.Boundary(0, 196, 300, 4),
        left: new entity.Boundary(0, 0, 4, 200),
        right: new entity.Boundary(296, 0, 4, 200),
        spawn_alien: new entity.PlayerSpawn(50, 20, 'Alien'),
        spawn_human: new entity.PlayerSpawn(230, 20, 'human'),
        row1_left: new entity.Boundary(40, 55, 60, 4),
        row1_right: new entity.Boundary(200, 55, 60, 4),
        row1_barrier_middle: new entity.Boundary(148, 30, 4, 40),
        row1_barrier_right: new entity.Boundary(200, 59, 4, 15),
        row1_barrier_left: new entity.Boundary(96, 59, 4, 15),
        row2_middle: new entity.Boundary(115, 110, 70, 4),
        row2_left: new entity.Boundary(30, 110, 50, 4),
        row2_right: new entity.Boundary(220, 110, 50, 4),
        row3_left: new entity.Boundary(40, 150, 90, 4),
        row3_right: new entity.Boundary(170, 150, 90, 4),
        laser_1_right: new entity.Laser(152, 55, 48, 15, false, '#21b2b4'),
        laser_1_left: new entity.Laser(100, 55, 48, 15, false, '#21b2b4'),
        laser_1_button: new entity.Button(148, 108, function() {
          level.midground.laser_1_right.on = true;
          return level.midground.laser_1_left.on = true;
        }, function() {
          level.midground.laser_1_right.on = false;
          return level.midground.laser_1_left.on = false;
        }, true, '#21b2b4'),
        laser_2_middle: new entity.Laser(148, 4, 4, 26, false),
        laser_2_right_button: new entity.Button(204, 53, function() {
          return vars.laser_2_right_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_right_button = false;
          if (!vars.laser_2_left_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true),
        laser_2_left_button: new entity.Button(92, 53, function() {
          return vars.laser_2_left_button = level.midground.laser_2_middle.on = true;
        }, function() {
          vars.laser_2_left_button = false;
          if (!vars.laser_2_right_button) {
            return level.midground.laser_2_middle.on = false;
          }
        }, true),
        suddenDeath: new entity.SuddenDeath(this, 23)
      };
      this.spawner = new Item_Spawner(this.midground, ['Bomb', ['Bomb', true, false], ['Bomb', false, true], ['Bomb', true, true], 'NoWingsEnemy', 'AddLife'], this.width, this.height, 7);
      _ref = [players, this.midground, this.foreground];
      _results = [];
      for (i in _ref) {
        source = _ref[i];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (ii in source) {
            ent = source[ii];
            _results1.push(ent != null ? typeof ent.onBuild === "function" ? ent.onBuild(this) : void 0 : void 0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    shake: {
      shaking: false,
      speed: 3,
      dir: {
        x: 1,
        y: 1
      },
      dist: {
        x: 6,
        y: 3
      },
      timeout: {},
      start: function(duration) {
        if (duration == null) {
          duration = 300;
        }
        if (typeof this.timeout === "function") {
          this.timeout();
        }
        this.shaking = true;
        return this.timeout = setFrameTimeout((function(_this) {
          return function() {
            return _this.shaking = false;
          };
        })(this), duration);
      },
      update: function() {
        if (this.shaking) {
          if (Math.abs(level.offsetX) >= this.dist.x) {
            this.dir.x *= -1;
          }
          if (Math.abs(level.offsetY) >= this.dist.y) {
            this.dir.y *= -1;
          }
          level.offsetX += this.speed * this.dir.x;
          return level.offsetY += this.speed * this.dir.y;
        } else {
          level.offsetX = 0;
          return level.offsetY = 0;
        }
      }
    },
    floatingScores: [],
    addFloatingScore: function(x, y, amount) {
      return this.floatingScores.push({
        x: x,
        y: y,
        amount: amount,
        alpha: 1,
        container: this.floatingScores,
        update: function() {
          this.y -= 0.8;
          this.alpha -= 0.02;
          if (this.alpha <= 0) {
            return this.container.splice(this.container.indexOf(this), 1);
          }
        },
        draw: function(ctx) {
          return ctx.save().globalAlpha(this.alpha).font('Helvetica').textBaseline('top').textAlign('center').fillStyle(this.amount <= 0 ? '#e00005' : '#79df06').fillText(this.amount, this.x, this.y).restore();
        }
      });
    },
    update: function() {
      this.render.canvas.width = this.width;
      this.render.canvas.height = this.height;
      if (players.human.lives === 0) {
        this.winner = 'Alien';
      }
      if (players.alien.lives === 0) {
        this.winner = 'human';
      }
      return level.shake.update();
    },
    drawBackground: function() {
      return this.render.save().fillStyle('#383838').fillRect(0, 0, this.width, this.height).restore();
    },
    drawMidground: function() {
      var ent, i, _ref;
      this.render.save();
      _ref = this.midground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      return this.render.restore();
    },
    drawForeground: function() {
      var ent, i, _ref;
      this.render.save();
      _ref = this.foreground;
      for (i in _ref) {
        ent = _ref[i];
        if (typeof ent.update === "function") {
          ent.update();
        }
        if (typeof ent.draw === "function") {
          ent.draw(this.render);
        }
      }
      return this.render.restore();
    }
  };

  Player = (function() {
    function Player(playerType, color, controlScheme) {
      this.color = color;
      this.x = 0;
      this.y = 0;
      this.width = 7;
      this.height = 12;
      this.xForce = 1.7;
      this.yForce = 2;
      this.spawn = void 0;
      this.item = void 0;
      this.cache = {};
      this.vel = {
        x: 0,
        y: 0,
        mod: {
          gravity: {
            x: 0,
            y: 0
          }
        }
      };
      ({
        pause: false
      });
      this.playerType = playerType;
      this.effects = {};
      this.onBuild = function(level) {
        this.other = players[playerType === 'alien' ? 'human' : 'alien'];
        this.maxLives = 5;
        this.lives = this.maxLives;
        return this.score = 0;
      };
      this.events = {
        top_col: function(ent) {
          if (ent.solid || (typeof ent.isSolidTo === "function" ? ent.isSolidTo(players[playerType]) : void 0)) {
            return players[playerType].vel.mod.up.y = 0;
          }
        },
        bottom_col: function(ent) {
          var _ref;
          if (ent.solid || (typeof ent.isSolidTo === "function" ? ent.isSolidTo(players[playerType]) : void 0)) {
            players[playerType].vel.mod.gravity.y = 0;
            if (!((_ref = players[playerType].keys.w) != null ? _ref.pressed : void 0)) {
              removePlayerVelocity(playerType, 'up');
            }
          }
          if (ent.type === 'Player') {
            return ent.die((function(_this) {
              return function() {
                return modifyPlayerScore(playerType, 50);
              };
            })(this));
          }
        },
        left_col: function() {},
        right_col: function() {}
      };
      this.keys = {};
      this.keys[controlScheme.up] = {
        press: function() {
          addPlayerVelocity(playerType, 'up', {
            y: -players[playerType].yForce
          });
          return players[playerType].vel.mod.gravity.y = 0;
        }
      };
      this.keys[controlScheme.down] = {
        press: function() {
          return removePlayerVelocity(playerType, 'up');
        }
      };
      this.keys[controlScheme.left] = {
        press: function() {
          return addPlayerVelocity(playerType, 'left', {
            x: -players[playerType].xForce
          });
        },
        release: function() {
          return removePlayerVelocity(playerType, 'left');
        }
      };
      this.keys[controlScheme.right] = {
        press: function() {
          return addPlayerVelocity(playerType, 'right', {
            x: players[playerType].xForce
          });
        },
        release: function() {
          return removePlayerVelocity(playerType, 'right');
        }
      };
      this.keys[controlScheme.item] = {
        press: function() {
          return players[playerType].useItem();
        }
      };
    }

    Player.prototype.type = 'Player';

    Player.prototype.isSolidTo = function() {
      return true;
    };

    Player.prototype.useItem = function() {
      var _ref;
      return (_ref = this.item) != null ? _ref.use() : void 0;
    };

    Player.prototype.removeEffect = function(name) {
      if (this.effects[name] != null) {
        this.effects[name].timeout();
        this.effects[name].remove();
        this.effects[name] = void 0;
        return delete this.effects[name];
      }
    };

    Player.prototype.addEffect = function(name, add, remove, time) {
      var _ref;
      if ((_ref = this.effects[name]) != null) {
        _ref.timeout();
      }
      remove();
      add();
      return this.effects[name] = {
        remove: remove,
        timeout: setFrameTimeout((function(_this) {
          return function() {
            remove();
            _this.effects[name] = void 0;
            return delete _this.effects[name];
          };
        })(this), time)
      };
    };

    Player.prototype.update = function() {
      var mod, name, _ref;
      if (!this.pause) {
        this.vel.mod.gravity.y += gravity;
        this.vel.x = 0;
        this.vel.y = 0;
        _ref = this.vel.mod;
        for (name in _ref) {
          mod = _ref[name];
          if (mod.x) {
            this.vel.x += mod.x;
          }
          if (mod.y) {
            this.vel.y += mod.y;
          }
        }
      }
      return applyPhysics(this);
    };

    Player.prototype.die = function(before, after) {
      var _ref;
      if ((_ref = this.spawn) != null ? _ref.closed : void 0) {
        if (typeof before === "function") {
          before();
        }
        this.lives--;
        this.vel = {
          x: 0,
          y: 0,
          mod: {
            gravity: {
              x: 0,
              y: 0
            }
          }
        };
        this.spawn.reset();
        return typeof after === "function" ? after() : void 0;
      }
    };

    Player.prototype.draw = function(ctx, delta, time) {
      if (level != null) {
        if (!this.spawn.closed) {
          ctx.save().globalAlpha(0.5).strokeStyle(this.color).lineWidth(2).strokeRect(Math.round(this.x), Math.round(this.y), this.width, this.height).restore();
        }
        ctx.save().fillStyle(this.color).fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);
        if (this.item != null) {
          if (this.item.draw != null) {
            this.item.draw(ctx);
          } else {
            ctx.fillStyle(this.item.color).fillRect(Math.round(this.x + this.width / 2 - 2), Math.round(this.y + this.height / 2 - 2), 4, 4);
          }
        }
        return ctx.restore();
      }
    };

    return Player;

  })();

  players.human = new Player('human', '#db9b63', {
    up: 'up',
    down: 'down',
    left: 'left',
    right: 'right',
    item: 'period'
  });

  players.alien = new Player('alien', '#9be83c', {
    up: 'w',
    down: 's',
    left: 'a',
    right: 'd',
    item: 'g'
  });

  touchMove = false;

  touchTimeout = {};

  this.mouse = mouse = {
    x: 0,
    y: 0,
    down: false,
    up: false
  };

  gameCq = cq().framework({
    onresize: function(width, height) {
      if (mouse.x > width) {
        mouse.x = width;
      }
      if (mouse.y > height) {
        mouse.y = height;
      }
      this.canvas.width = width;
      this.canvas.height = height;
    },
    onmouseup: mouseUpHandler = function(x, y, btn) {
      mouse.down = false;
      return mouse.up = true;
    },
    onmousedown: mouseDownHandler = function(x, y, btn) {
      return mouse.down = true;
    },
    onmousemove: mouseMoveHandler = function(x, y) {
      mouse.x = x;
      return mouse.y = y;
    },
    ontouchstart: function(x, y, touch) {
      if (touch.length === 1) {
        touchDown = true;
        return mouseMoveHandler(x, y);
      }
    },
    ontouchmove: function(x, y, touch) {
      touchMove = true;
      return mouseMoveHandler(x, y);
    },
    ontouchend: function(x, y, touch) {
      touchDown = false;
      if (!touchMove) {
        mouseDownHandler(x, y);
        touchTimeout();
        touchTimeout = setFrameTimeout(function() {
          return mouseUpHandler(x, y);
        }, 100);
      }
      return touchMove = false;
    },
    onkeydown: function(key, e) {
      var name, player, _base, _results;
      _results = [];
      for (name in players) {
        player = players[name];
        if ((player.keys[key] != null) && !player.keys[key].pressed) {
          player.keys[key].pressed = true;
          _results.push(typeof (_base = player.keys[key]).press === "function" ? _base.press() : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    onkeyup: function(key) {
      var name, player, _base, _results;
      _results = [];
      for (name in players) {
        player = players[name];
        if ((player.keys[key] != null) && player.keys[key].pressed) {
          player.keys[key].pressed = false;
          _results.push(typeof (_base = player.keys[key]).release === "function" ? _base.release() : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    onrender: function(delta, time) {
      var name, player;
      this.clear('#202424');
      if (level != null) {
        this.context.mozImageSmoothingEnabled = this.context.webkitImageSmoothingEnabled = this.context.msImageSmoothingEnabled = this.context.imageSmoothingEnabled = false;
        level.render.context.mozImageSmoothingEnabled = level.render.context.webkitImageSmoothingEnabled = level.render.context.msImageSmoothingEnabled = level.render.context.imageSmoothingEnabled = false;
        resizeFactor = Math.min(gameCanvas.width / level.width, gameCanvas.height / (level.height + 20));
        updateFrameTimeouts();
        if (typeof level.update === "function") {
          level.update();
        }
        if (!level.winner) {
          if (typeof level.drawBackground === "function") {
            level.drawBackground();
          }
          for (name in players) {
            player = players[name];
            if (typeof player.update === "function") {
              player.update();
            }
            if (typeof player.draw === "function") {
              player.draw(level.render, delta, time);
            }
          }
          if (typeof level.drawMidground === "function") {
            level.drawMidground();
          }
          if (typeof level.drawForeground === "function") {
            level.drawForeground();
          }
        } else {
          level.render.save().font('2em Helvetica').textAlign('center').textBaseline('middle').fillStyle(players[level.winner.toLowerCase()].color).wrappedText("The " + level.winner + " won!", level.width / 2, level.height / 2 - 10, level.width).font('1em Helvetica').fillText('Scores:', level.width / 2, level.height / 2 + 10).textBaseline('top').fillStyle(players.alien.color).fillText("Alien: " + players.alien.score, level.width / 2, level.height / 2 + 20).fillStyle(players.human.color).fillText("Human: " + players.human.score, level.width / 2, level.height / 2 + 35).restore();
        }
        this.save().translate((gameCanvas.width / 2 + level.offsetX) - (level.width * resizeFactor) / 2, (gameCanvas.height / 2 + level.offsetY) - (level.height * resizeFactor) / 2).drawImage(level.render.canvas, 0, 0, level.width * resizeFactor, level.height * resizeFactor).restore();
      }
      mouse.up = false;
    }
  });

  gameCanvas = gameCq.canvas;

  onEvent('assetsLoaded', function() {
    console.log('loaded');
    loadLevel('middle');
    gameCanvas.width = root.innerWidth;
    gameCanvas.height = root.innerHeight;
    gameCq.appendTo('body');
    mouse.x = gameCanvas.width / 2;
    mouse.y = gameCanvas.height / 2;
    mouse.up = false;
    return mouse.down = false;
  });

}).call(this);
